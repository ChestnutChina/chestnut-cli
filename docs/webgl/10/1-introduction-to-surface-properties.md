## 表面属性简介

你的眼睛 "看到 "一个物体，是因为光线从该物体上反射到你的眼睛。表面的属性会影响光线从物体上反射的方式。

本课讨论了表面的基本特性以及用于计算反射光和表面的相互作用的数学知识。

### 课程概述

在前面的课程中，你学到了如何对光线及其在表面上的反射进行建模。当像素的颜色以反射光为基础时，渲染图看起来是不是很神奇呢！？然而，我们用单一的颜色来表示模型的外观，这使得模型的渲染过于统一和 "纯粹"。真实世界的物体在其表面有更多的变化。对模型的三角形的表面属性进行建模是我们在WebGL计算机生成的图像中[接近照片般真实的地方](https://en.wikipedia.org/wiki/Unbiased_rendering)。(要获得精确的 "照片般的真实感"，你必须使用[光线追踪](https://en.wikipedia.org/wiki/Ray_tracing_(graphics))，这是一种完全不同的渲染3D计算机图形图像的方法）。

表面属性很复杂，我们无法涵盖图形程序可能使用的所有属性。但我们将涵盖基本的内容，即：

- 颜色：表面的颜色实际上不是单一的颜色，而是一组颜色，因为表面实际上对环境光、漫射光和镜面光反射的反应是不同的。
- 方向。WebGL只渲染三角形，但我们可以修改三角形顶点的法向量来模拟曲面。
- 纹理。一个表面可以有多种颜色。一件衣服就是一个很好的例子。
- 平滑与凹凸不平。一个表面可能不是光滑的，而是凹凸不平的。
- 闪亮与暗淡。一个表面在显微镜下可能是不规则的，看起来很 "暗淡"，因为它从各个方向反射光线，甚至镜面反射。或者它在显微镜下可能非常光滑，镜面反射的散射最小。

### 代码概述

你的JavaScript代码将设置一个模型的表面属性，你的GPU碎片着色器程序将使用这些属性来计算一个三角形的每个碎片的颜色。

有很多情况下，可以构建你的表面属性描述。主要的问题是，一个模型的所有表面是否都有相同的属性，还是单个表面有不同的属性。在你设计模型和实现着色器程序时，你需要考虑这些问题。请记住，在内存使用和渲染速度之间总是要进行权衡的。下表总结了这些问题。

| 模型表面： | 渲染 | 表面属性定义为：|
| -- | -- | -- |
| 所有表面都具有相同的属性 | 为整个模型调用 gl.drawArrays() | 统一变量 |
| 各个表面具有不同的属性 | 为每一组具有相同属性的表面调用一次gl.drawArrays() | 统一变量 |
| 各个表面具有不同的属性 | 为整个模型调用 gl.drawArrays() | 属性变量 |

### 表面属性转换

与前几课一样，我们将在 "相机空间 "中进行碎片着色器的计算，因为:
- GPU着色器程序知道摄像机的位置和方向，而无需更新任何统一的变量。(摄像机位于全局原点并与全局轴对齐）。
- 让摄像机位于原点可以简化一些照明计算。

这意味着任何与模型的位置或方向有关的表面属性都必须被转换到 "相机空间"。这在大多数情况下是很直接的，但如果你的转换包括非均匀缩放，就会出现问题。请注意，摄像机的转换从来不包括缩放--只包括旋转和平移。因此，如果你的模型转换包括非均匀缩放，那么问题就来了。

### 不缩放或统一缩放

如果你的模型转换包括平移、旋转和/或统一缩放，你可以使用你的模型-视图转换将模型的法向量转换成 "相机空间"。记住，向量没有位置，只有大小和方向。因此，一个向量的同质坐标必须为零，这样平移就永远不会应用到它。矢量\<dx,dy,dz>在乘以模型-视图变换之前变成\<dx,dy,dz,0>。

注意，你永远不能在模型法线向量上使用你的投影-视图-模型转换。投影矩阵通常包含非均匀缩放，并将顶点置于与相机视图不同的三维空间。

### 非均匀缩放

考虑一下图。如果你对一个包含非均匀缩放的模型进行变换，那么法线向量就会变得歪斜，不能指向正确的方向。这个简单的例子表明，用于模型顶点的模型-视图变换对模型的法向量不起作用--如果变换包括非均匀缩放。

<center>
  <img src="/10/non_uniform_scaling.png" />
</center>

让我们来计算一个能正确转换法向量的变换。假设我们有一个矢量，p，位于顶面的平面内。p和n之间的角度必须是90度。这意味着p和n的点积，即等于它们之间的角度的余弦，必须是零。因此:
```js
dot(p,n) === 0
```

让M成为包含模型的非均匀缩放的变换。因此p'=M*p。我们需要求解一个不同的变换，S，将n变换成n'，使dot(p',n')===0。 因此：
```js
dot(M * p, S * n) === 0
```

你可以通过对每个矩阵的转置来重新排列矩阵与向量的乘法，比如这样:
::: tip Eq1
$$
\begin{bmatrix}
a & b & c & d \\
e & f & g & h \\
i & j & k & l \\
m & n & o & p
\end{bmatrix} * \begin{bmatrix}
x \\
y \\
z \\
0
\end{bmatrix} = \begin{bmatrix} x & y & z & 0 \end{bmatrix} * \begin{bmatrix}
a & e & i & m \\
b & f & j & n \\
c & g & k & o \\
d & h & l & p 
\end{bmatrix}
$$ 
:::

因此，$dot(p^T * M^T, S * n) === 0$。

由于$dot(p, n) === 0, M^T * S$必须等于身份矩阵。我们可以用这个事实来解决S的问题.

::: tip Eq2
$M^T * S === I$

$(M^T)^{-1} * M^T * S === (M^T)^{-1} * I$

$S === (M^T)^{-1}$

$S === (M^{-1})^{T}$(请参阅下面的矩阵恒等式)
:::

<center>
  <img src="/10/transformed_vectors.png" />
</center>

### 总结

如果你在模型转换中使用非均匀缩放，你的JavaScript代码必须为一个模型渲染创建三个独立的转换：

- 一个模型-视图转换，将模型的顶点转换到 "摄像机空间"。
- 模型-视图反转转换，将模型的法向量转换到 "摄像机空间"。
- 一个投影-视图-模型的转换，将模型的顶点转换为图形管道。

在这些教程的其余部分，我们将假设在模型的转换中没有非均匀的缩放。

### 基本矩阵标识

矩阵运算的下列性质为真 (1)，其中 A 和 B 是方阵，$A^T$ 是 A 的转置，$A^{-1}$ 是 A 的逆矩阵。

- $(A*B)^T = B^T * A^T$
- $(A^T)^T = A$
- $(A+B)^T = A^T + B^T$
- $(A*B)^{-1} = B^{-1} * A^{-1}$
- $(A^{T})^{-1} = (A^{-1})^T$