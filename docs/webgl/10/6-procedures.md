## 纹理映射

纹理映射是一种为组成三角形的每个片段指定唯一颜色的技术。颜色来自映射，这是一个将一组输入转换为输出值的函数。有两种基本方法可以做到这一点：

- 从可能值列表中查找输出值。这称为“表查找”。在计算机图形学中，这称为基于图像的纹理映射。
- 对一组输入执行计算以产生输出值。

本课介绍第二种映射技术背后的基本思想：如何计算颜色。由于计算通常放在单独的函数中，因此这种类型的纹理映射称为过程纹理映射。

### 概述

基于图像的纹理映射和基于过程的纹理映射不是相互竞争的技术；它们是互补的技术，每个都有适当的用途。事实上，这两种技术经常一起使用来创建更逼真的表面。以下是程序纹理映射的一些优点和缺点。

优点：

- 与基于图像的纹理映射相比，程序纹理映射需要更少的内存。没有要下载或存储在 RAM 或 GPU 内存中的图像。
- “放大”和“缩小”的问题消失了。程序纹理映射在任何和所有比例下都能正常工作。
- 程序纹理贴图可以生成各种各样的图案，只需对其计算进行微调。要使用基于图像的纹理映射获得相同的效果，每个图案都需要一个单独的图像。

缺点：

- 在渲染时为每个单独的片段计算程序纹理贴图。如果计算复杂，渲染速度会变慢。
- 程序纹理映射所需的计算可能很复杂，并且很难修改方程式以实现您尝试创建的特定效果。
- 程序纹理映射创建图案。如果您需要专门应用于模型表面的东西，例如包含文字的路标，基于图像的纹理映射是最好的方法。

程序纹理映射将输入值转换为颜色。输入值可以是与三角形属性相关的任何内容，例如它的位置、方向、漫反射颜色等。但是，我们通常不希望模型的表面属性因为它的位置和/或方向而改变。例如，您不希望模型中的木纹在场景中移动一块木头时发生变化；从任何位置或角度看，木纹都应该是一样的。您可以使用纹理坐标作为计算程序纹理贴图颜色的输入，因为纹理坐标通常不会随着模型的变换而改变。或者，您可以在对其应用任何变换之前使用模型的几何形状。

程序纹理映射由片段着色器程序执行。此类程序的复杂性没有限制，但增加的复杂性意味着渲染速度较慢。如果您需要使用不同的程序纹理贴图来渲染各种模型，那么为每个渲染实现单独的着色器程序会更有效。另一种方法是在单个着色器程序中使用 if 语句在渲染时选择适当的程序纹理贴图，但这会减慢所有渲染速度。

### 软件概述

创建程序纹理映射的基本步骤如下：

1. 构建模型时
    - 为三角形的每个顶点分配一个适当的纹理坐标 (s,t)。 （如果模型的几何图形用于纹理映射输入，则可以跳过此步骤。）
2. 用于画布渲染的 JavaScript 预处理
    - （没有任何）
3. 每次使用程序纹理贴图渲染模型时的 JavaScript 设置
    - 使用 gl.useProgram() 选择正确的着色器程序
4. 着色器程序
    - 在顶点着色器中，创建一个可变变量，该变量将在三角形表面上插入纹理坐标。 （或者在脸上插入模型的一些其他属性。）
    - 在片段着色器中，使用纹理坐标（或其他一些插值）来计算颜色。

如您所见，这比基于图像的纹理映射要简单得多。基本上与程序纹理映射相关的所有内容都在片段着色器程序中执行。本课的剩余部分介绍了创建程序纹理贴图的三种技术：

- 渐变
- 叠加图案
- 噪声（随机性）

要完全理解这些技术，您需要花一些时间在下面的每个演示程序上，并执行建议的实验。不要犹豫，自己做实验！

### 渐变

从一种颜色到另一种颜色的平滑过渡通常称为“渐变颜色”。这个简单的想法有很多变化。下面的演示程序渲染了一个简单的立方体，其中立方体的每一面都有纹理坐标，每个面的范围从 0.0 到 1.0。研究片段着色器，然后使用以下建议的每个渐变函数对其进行修改。希望对每个梯度函数的描述能够清楚地说明该函数是如何工作的。

点击查看[交互式例子](http://learnwebgl.brown37.net/10_surface_properties/texture_mapping_procedural.html#gradients)

[在新的标签或窗口中打开这个webgl程序](http://learnwebgl.brown37.net/10_surface_properties/gradient/gradient.html)

### 梯度实验

上面演示程序中的片段着色器使用纹理坐标的 s 分量作为面部颜色的百分比。面部的颜色在片段着色器中被“硬编码”为红色，但面部的颜色可能来自三角形的属性变量。请注意，操作 red * percent 是逐个组件相乘，因为 red 是一个向量，而 s 是一个标量（单个值）。即red * percent的结果是一个新的向量（red[0]*percent, red[1]*percent, red[2]*percent）。

通过尝试以下代码修改进行实验。每次更改后单击“重新启动”按钮以查看结果。如果在片段着色器程序中引入错误，错误消息将显示在画布窗口下方的“运行信息”显示区域和 JavaScript 控制台窗口中。

- 将变量 red 更改为不同的颜色。
- 使用纹理坐标的 t 分量。也就是说，百分比 = t;。请注意渐变现在如何切换方向以在面部而不是向上移动。
- 使用纹理坐标的 s 分量，但反转它的方向。也就是说，百分比 = 1.0 - s;。注意渐变现在是如何切换方向的。
- 尝试百分比 = s + t;。这会产生介于 0.0 和 2.0 之间的值。所有大于 1.0 的值都被限制为 1.0。这会产生纯色的饱和三角形。面部 (s+t) 大于 1.0 的每个位置都将获得全彩。
- 尝试百分比 = (s+t)/2.0;。这会将总和缩放到始终介于 0.0 和 1.0 之间，并在整个面部产生良好的渐变。
- 尝试百分比 = (s+t)/3.0;。这会将总和缩放到始终介于 0.0 和 (2/3) 之间，并在整个面部产生一个很好的渐变，但颜色永远不会饱和到全色。
- 尝试百分比 = s * t;。这会产生介于 0.0 和 1.0 之间的百分比，但这些值不是线性的。因此渐变只会使一个角落的颜色饱和。
- 尝试百分比 = sin(s);。请记住，三角函数始终使用弧度，因此这是计算 0.0 到 1.0 弧度（57.2958 度）之间角度的正弦值。颜色永远不会饱和，因为百分比介于 0.0 和 0.84 之间。
- 试试百分比 = sin(s * PI/2.0);。这会计算 0.0 到 1.0 之间的百分比，因为 s 分量被缩放到 0.0 到 pi/2（90 度）之间的值。 PI 不是着色器语言中定义的常量，所以需要这样定义：float PI = 3.141592653589793;
- 尝试百分比 = sin(s * 2.0*PI);。这会计算 1.0 到 -1.0 之间的百分比，因为它将 s 缩放为 0.0 到 360.0 度 (2*PI) 之间的角度。所有低于 0.0 的值都被限制为 0.0，这会产生纯黑色的区域。
- 试试百分比 = abs(sin(s * 2.0*PI));。这会计算 0.0 和 1.0 之间的百分比，因为 abs() 函数采用其参数的绝对值。注意漂亮的两个“色带”。当 2.0*PI 变为 3.0*PI 时会发生什么？ n*PI 会发生什么？
- 尝试百分比 = sin(s * 2.0*PI) * sin(t * 2.0*PI);。这会产生渐变圆。如果添加 abs() 函数，您将获得统一的圆圈。如果将 2.0 因子更改为其他值，则会得到那么多圈。尝试删除 2.0 因子。

上述所有实验都计算一个百分比值，然后按该百分比缩放基色。您可以使用百分比、百分比和剩余部分（1.0%）在两种不同颜色之间制作渐变，以像这样缩放两种颜色。

```js
vec3 red = vec3(1.0, 0.0, 0.0);
vec3 blue = vec3(0.0, 0.0, 1.0);

percent = abs(sin(s * 2.0*PI));
return vec4( red * percent + blue * (1.0-percent), 1.0);
```

请尝试两种颜色渐变。

希望您了解渐变的概念！想想可能性！上述实验甚至还没有接近可能的变化。

您可以通过使部分计算成为在渲染时设置的统一变量来“概括”渐变纹理贴图。例如，函数百分比 = abs(sin(s * n*PI));在脸上产生“n”条颜色。您可以将 n 设为统一变量、统一浮点 n;，并在渲染之前在 JavaScript 初始化代码中设置其值。

### 叠加模式

创建程序纹理贴图的第二种基本技术是创建一个基本图案，然后以不同的比例将其叠加在其自身之上。当您通过一些示例工作时，这将更有意义。

#### 棋盘图案

以下 WebGL 演示程序创建了一个棋盘模式。研究下面的片段着色器程序，注意名为 checkerboard 的函数计算纹理坐标是图案的“白色”还是“黑色”瓷砖的一部分。该函数返回 0.0 或 1.0。叠加函数使用从棋盘格返回的百分比计算颜色。传递给棋盘函数的比例因子确定棋盘图案中的瓷砖数量。将第 29 行中的比例因子更改几次以查看结果。

点击查看[交互式例子](http://learnwebgl.brown37.net/10_surface_properties/texture_mapping_procedural.html#checkerboard-pattern)

[在新的标签或窗口中打开这个webgl程序](http://learnwebgl.brown37.net/10_surface_properties/checkerboard/checkerboard.html)

我们想要创建一个模式，它是这种模式在不同尺度上的组合。可以通过多种方式组合模式，我们将只研究其中的几种。为确保思路清晰，修改片段着色器以计算棋盘图案两次，然后每次计算取 50%。 （提示：使用复制/粘贴来避免输入错误。）

```js
float percent = 0.5 * checkerboard(tex_coords, 2.0) +
                0.5 * checkerboard(tex_coords, 3.0);
```

使用 3 种不同的比例再试一次：

```js
float percent = 0.33 * checkerboard(tex_coords, 2.0) +
                0.33 * checkerboard(tex_coords, 3.7) +
                0.33 * checkerboard(tex_coords, 7.0);
```

希望你能看到模式。我们可以编写一个循环来创建这样的模式总和。请注意，WebGL GLSL 中的循环必须为其循环控制变量提供一个常量。这就是为什么 n 被声明为 const （常量）值的原因。
```js
// Set the number of patterns to overlay
const int n = 5;

// Set the starting scale of the pattern
float scale = 2.0;

float percent = 0.0;
for (int j=0; j<n; j++) {
  percent += (1.0/float(n)) * checkerboard(tex_coords, scale);

  // Increase the scale of the pattern
  scale *= 2.0;
}
```

请注意，此代码中有三个“参数”：n 是要覆盖的图案数量，scale 是控制每个图案的比例，并且 (1.0/float(n)) 分数占每个图案的相等百分比。这为我们提供了许多控制此纹理贴图的选项。尝试各种方法来修改音阶，例如：

- scale  += 1.0； （值将是 2、3、4、5 等）
- scale  += 2.0； （值将是 2、4、6、8 等）
- scale  += 2.5； （值将是 2、4.5、7、9.5 等）
- scale  *= 2.0; （值将是 2、4、8、16 等）
- scale  *= 3.0; （值将是 2、6、24、72 等）
- scale = table[j];，其中
    ```js
    float table[5];
    table[0] = 2.0;
    table[1] = 3.7;
    table[2] = 4.1;
    table[3] = 8.3;
    table[4] = 12.7;
    ```

还可以尝试不同的 n 值。

现在我们有了这个想法中最复杂的部分，即组合部分。有很多方法可以组合不同的缩放模式。以下是一些可以尝试的组合技术：

- 交替添加或减去每个比例的值。这可以通过在循环内翻转符号值来完成，如下所示：
    ```js
    const int n = 5;
    float scale = 2.0;
    float percent = 0.0;
    float sign = 1.0;
    for (int j=0; j<n; j++) {
      percent += sign * checkerboard(tex_coords, scale);
      scale *= 2.0;
      sign = -sign;
    }
    ```
- 不是使用每个缩放纹理的相等百分比，而是使用加权百分比，将某些图案视为更重要。以下代码使用公式 1.0/pow(2,j+1) 使用 (1/2)、(1/4)、(1/8) 等的百分比。 （如果您想将较小的比例视为更重要，您可以反转百分比，1.0/pow(2,n-j)
    ```js
    const int n = 5;
    float scale = 2.0;
    float percent = 0.0;
    for (int j=0; j<n; j++) {
      percent += (1.0/pow(2.0,float(j+1))) * checkerboard(tex_coords, scale);
      scale *= 2.0;
    }
    ```

### 圆形渐变

让我们结合不同比例的“圆形渐变”图案的叠加。使用这个新的基础来试验叠加层的各种“参数”：

- n，要叠加的图案数量，
- 比例尺，基本图案的各种比例尺，以及
- (1.0/float(n))，组合技术。

点击查看[交互式例子](http://learnwebgl.brown37.net/10_surface_properties/texture_mapping_procedural.html#circular-gradient)

[在新的标签或窗口中打开这个webgl程序](http://learnwebgl.brown37.net/10_surface_properties/circular_overlays/circular_overlays.html)

可以使用其他基本模式来代替棋盘或圆形渐变功能。随意修改或替换这些功能进行试验。

### 噪声（随机性）

基本纹理的第三种技术是使用随机性。随机数生成器是大多数编程语言库的标准部分，但 WebGL GLSL 中没有内置的“随机”函数。因此，我们将使用由 [Ashima Arts](https://github.com/ashima/webgl-noise) 编写的第三方功能。我们将使用他的 2D cnoise() 和 pnoise() 函数，而不涉及它们背后的数学，因为数学很重要，它对我们的概述讨论并不重要。

一般来说，计算机要制造“随机性”并不容易。它们通常旨在创建“看似”随机但实际上非常可预测的“伪随机”数字序列。对于计算机图形来说，这是极其重要的。我们想在一个面上生成一个随机纹理，但我们希望每次渲染这个面时都具有相同的“随机性”。如果我们不能获得相同的随机性，纹理会在每次渲染时发生变化，这在大多数情况下不会在视觉上吸引人。

请研究以下 WebGL 演示程序中的片段着色器。跳过第 1-119 行的“噪声”生成器代码，专注于第 120-140 行的片段着色器代码。请注意，我们使用从“噪声”生成器返回的百分比值来创建灰色阴影，方法是使用每个颜色分量的百分比值，即 (percent, percent, percent)。这有助于您更好地可视化“噪音”。

点击查看[交互式例子](http://learnwebgl.brown37.net/10_surface_properties/texture_mapping_procedural.html#noise-randomness)

[在新的标签或窗口中打开这个webgl程序](http://learnwebgl.brown37.net/10_surface_properties/noise/noise.html)

Ashima 的 cnoise() 函数返回一个介于 -1.0 和 +1.0 之间的随机值。要将这个值用于颜色分量，我们添加 1.0 以获得 0.0 到 2.0 范围内的值，然后除以 2.0 得到 0.0 到 1.0 之间的百分比。这纯粹是为了可视化随机模式。对于其他纹理映射情况，您可能希望也可能不希望这样做。请注意，cnoise() 返回的值在随机数生成器的意义上不是随机的。相反，它们提供了面部表面梯度的随机变化。可以通过将纹理坐标乘以比例因子来缩放这种梯度变化。试试这个变种到第 132 行：

- float percent = (1.0 + cnoise(2.0 * tex_coords)) / 2.0;
- float percent = (1.0 + cnoise(3.2 * tex_coords)) / 2.0;
- float percent = (1.0 + cnoise(10.0 * tex_coords)) / 2.0;

请注意，随着比例的增加，随机模式不是周期性的，并且对于更大的比例因子，您会得到更复杂的模式。

#### 柏林噪声

Ashima 的 pnoise() 函数实现了 [Perlin 噪声](https://en.wikipedia.org/wiki/Perlin_noise)。这个函数需要一个额外的参数，它是 2 个“扰动”因子的向量。下面的 WebGL 演示程序允许您改变这两个因素来调查 Perlin 噪声的可能性。

点击查看[交互式例子](http://learnwebgl.brown37.net/10_surface_properties/texture_mapping_procedural.html#perlin-noise)

[在新的标签或窗口中打开这个webgl程序](http://learnwebgl.brown37.net/10_surface_properties/perlin_noise/perlin_noise.html)

请注意，如果您增加模式的比例，您可以更好地可视化 Perlin 噪声函数的变化。控制 s 和 t 因子的滑块可以使用键盘箭头键进行精细更改（在您移动特定滑块并将其设为活动滑块之后）。

当您对 s 和 t 因素进行试验时，请注意：

- 该模式会随着因素的微小变化而变化，但随后会从一种模式跳到另一种模式。这些因素不会在所有尺度上平滑地改变模式。
- 如果你可以使用 pnoise() 函数的 abs() （而不是加 1.0 并除以 2.0），你会得到不同的模式。
- 为所需的视觉效果选择 s 和 t 因子更像是一门“艺术”而不是“科学”。

### 其他噪声函数

您可能希望在未来某个时间研究的其他噪声函数包括：

- OpenSimplex 噪声：https://en.wikipedia.org/wiki/OpenSimplex_noise
- 小波噪声：http://graphics.pixar.com/library/WaveletNoise/paper.pdf
- 价值噪音：https://en.wikipedia.org/wiki/Value_noise
- 沃利噪音：https://en.wikipedia.org/wiki/Worley_noise

### 总结

我们已经研究了计算面部表面颜色的三种基本方法：渐变、不同比例的图案叠加和噪声。在下一节中，我们将研究结合这些想法来创建有趣和复杂的纹理。

### 参考

http://www.upvector.com/?section=Tutorials&subsection=Intro%20to%20Procedural%20Textures https://github.com/ashima/webgl-noise