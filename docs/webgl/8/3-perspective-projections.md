## 透视投影

透视投影渲染了一个虚拟场景，使其看起来像来自真实世界的摄像机的视图。离摄像机更远的物体看起来更小，所有的线条看起来都是向[消失点](https://en.wikipedia.org/wiki/Vanishing_point)投射的，从而使平行线倾斜。透视投影几乎总是被用于游戏、电影特效和虚拟世界的可视化。

本课将介绍如何创建一个透视投影，以及其4乘4变换矩阵背后的数学原理。

### 透视投影的视场

透视投影定义了一个三维区域，从摄像机的位置沿着四条边界射线投射出去。如图所示，这些射线形成了一个[视锥体](https://en.wikipedia.org/wiki/Viewing_frustum)。这个视域包括一个与X-Y平面平行的前后剪裁平面。任何在这个视域内的模型将被渲染。任何在这个视域之外的模型都将被剪掉。

<center>
  <img src="/8/viewing_frustum.png" />
  <p>
    <a href="https://en.wikipedia.org/wiki/Viewing_frustum" target="_blank">源码1</a>
  </p>
</center>

定义视锥体有两种标准方法。

- createPerspective()函数模拟了摄像机的镜头。摄像机总是在全局原点上向下看-Z轴。
- createFrustum()函数定义了一个与X-Y平面平行的二维观察窗口。摄像机可以位于X-Y平面的任何位置，但总是顺着平行于-Z轴的射线观察。这个函数的一个常见用途是渲染一个场景的两个不同视图，一个用于用户的左眼，另一个用于用户的右眼。如果这两幅渲染图被正确地偏移，并显示给用户的各个眼睛，用户就可以看到一个三维场景！这就是虚拟现实（VR）。这就是[虚拟现实](https://en.wikipedia.org/wiki/Virtual_reality)（VR）是如何产生的。

请研究这两种创建透视投影的方法。

### `createPerspective()` 函数

Learn_webgl_matrix.js模块中的函数createPerspective()可以创建一个透视投影变换矩阵。该函数需要4个参数，如下面的函数原型所示。

```js
/** -----------------------------------------------------------------
 * 使用视野和纵横比创建透视投影矩阵。
 * @param fovy   Number 视锥体上侧和下侧之间的角度.
 * @param aspect Number 查看窗口的纵横比。 （宽度/高度）.
 * @param near   Number 沿 -Z 轴到近剪裁平面的距离.
 * @param far    Number 沿 -Z 轴到远剪裁平面的距离.
 * @return Float32Array 透视变换矩阵.
 */
function createPerspective(fovy, aspect, near, far)
```

这四个参数定义了一个平截头体。 fovy 参数代表“视野 y 轴”，是相机镜头的垂直角度。 fovy 的常见值范围为 30 到 60 度。纵横比参数是画布窗口的宽度除以高度。近和远距离是您希望选择的任何正数，但限制是近总是小于远。近和远之间的距离应保持尽可能小，以减少精度问题，因为截锥体被映射到 2 个单位深的裁剪体积中。近和远的典型值可能是 0.1 到 100.0。一般来说，尽量靠近相机，尽量靠近相机。

<center>
  <img src="/8/side_view_frustum.png" />
</center>
使用以下演示对参数进行试验。

点击查看[交互式例子](http://learnwebgl.brown37.net/08_projections/projections_perspective.html#the-createperspective-function)

[在新的标签或窗口中打开这个webgl程序](http://learnwebgl.brown37.net/08_projections/create_perspective/create_perspective.html)

当您尝试透视参数时，请确保您观察到透视投影的以下特征。

- 随着相机镜头的角度（即fovy）变小，场景中的物体会变大。这与光如何穿过相机的光学系统是一致的。
- 如果纵横比发生变化但画布保持不变，则渲染将失真。作为程序员，您的工作是确保透视的纵横比与画布的纵横比相匹配。
- near 的值对渲染视图没有影响。它确实会影响从场景中剪裁的内容。 far 的值也是如此。
- near 和 far 参数始终为正，并且 near 应始终小于 far。 near 和 far 参数都是距离，而不是 Z 轴值。

### createFrustum() 函数

Learn_webgl_matrix.js 模块中的函数 createFrustum() 创建透视投影变换矩阵。该函数需要 6 个参数，如下面的函数原型所示。

```js
/** -----------------------------------------------------------------
 * 根据截锥体的限制设置透视投影矩阵.
 * @param left   Number x 轴最左边
 * @param right  Number x 轴最右边
 * @param bottom Number y 轴最下方
 * @param top    Number 在 y 轴上最远
 * @param near   Number 沿 -Z 轴到近剪裁平面的距离
 * @param far    Number 沿 -Z 轴到远剪裁平面的距离
 * @return Float32Array 透视变换矩阵
 */
function createFrustum (left, right, bottom, top, near, far)
```

3D 点（左、下、近）和（右、上、近）定义了查看窗口的左下角和右上角。如果计算观察窗的中心并将该点投射回 X-Y 平面，则该点就是截锥体的顶点。通过观察窗的四个点从顶点投射光线形成截锥体。 （顶点的位置在下面的演示中显示为一个小黑点。）

使用以下演示对参数进行试验。

点击查看[交互式例子](http://learnwebgl.brown37.net/08_projections/projections_perspective.html#the-createfrustum-function)

[在新的标签或窗口中打开这个webgl程序](http://learnwebgl.brown37.net/08_projections/create_frustum/create_frustum.html)

当您尝试使用截锥体参数时，请确保您观察到它创建的透视投影的以下特征。

- createFrustum 允许您创建一个与 -Z 轴“偏离中心”的平截头体，但它的视野始终平行于 -Z 轴。
- 作为程序员，您的工作是确保画布尺寸的纵横比（宽度/高度）与查看窗口的纵横比（左右）/（上下）一致。如果纵横比不同，则渲染将倾斜。
- 改变 near 的值对截锥体有深远的影响，因为这是从相机到观察窗的距离，并且整个截锥体由观察窗的角定义。改变 near 值从根本上改变了你的相机镜头的视野（这是由前面描述的 createPerspective 函数中的 fovy 参数控制的）。
- 改变 far 的值只会影响剪裁。
- 更改 left 和 right 的值会使相机的位置远离原点。
- 更改顶部和底部的值会使相机的位置远离原点。

### 透视投影矩阵

投影矩阵必须将场景中的顶点放入裁剪体积中，裁剪体积是右侧图像中显示的 2 个单位宽的立方体。为透视投影执行此操作比正交投影更具挑战性，因为需要对顶点进行更多操作。数学很简单，但需要一些特殊技巧才能将数学转换为 4x4 变换矩阵。我们需要执行以下步骤来创建透视投影变换矩阵：

1. 将平截头体的顶点平移到原点。
2. 执行透视计算。
3. 将查看窗口中的 2D (x',y') 值缩放为 2×2 单位正方形：(-1,-1) 到 (+1,+1)。
4. 将深度值 (z) 缩放到标准化范围 (-1,+1)。
5. 翻转 z 轴的方向以匹配裁剪体积的方向。

<center>
  <img src="/8/clipping_volume.png" />
</center>


让我们分别讨论这些任务。

#### 将平截头体顶点移动到原点

透视平截头体可以沿 X 或 Y 轴从全局原点偏移。我们需要将平截头体的顶点放在全局原点，以便透视计算起作用。顶点位于 XY 平面中观察窗的中心。因此，我们计算视窗的中心点并将其转换为原点。请注意，z 值未更改。

```js
mid_x = (left + right) * 0.5;
mid_y = (bottom + top)  * 0.5;
```

```html
┌               ┐   ┌   ┐   ┌    ┐ Eq1
│ 1 0 0  -mid_x │   | x |   | x' |
| 0 1 0  _mid_y | * | y | = | y' |
| 0 0 1       0 |   | z |   | z' |
| 0 0 0       1 |   | w |   | w' |
└               ┘   └   ┘   └    ┘
```
或者
```html
┌                        ┐   ┌   ┐   ┌    ┐ Eq2
│ 1 0 0  -(left+right)/2 │   | x |   | x' |
| 0 1 0  -(bottom+top)/2 | * | y | = | y' |
| 0 0 1                0 |   | z |   | z' |
| 0 0 0                1 |   | w |   | w' |
└                        ┘   └   ┘   └    ┘
```

#### 透视计算

我们需要将场景中的每个顶点投影到 2D 查看窗口中的正确位置。 2D 观察窗口是平截头体的近平面。研究右边的图表。请注意，顶点 (x,y,z) 通过将光线投射到相机（显示为橙色光线）投射到观察窗口。顶点的渲染位置是 (x',y',near)。从图中您可以看到 y 和 y' 值通过比例直角三角形相关联。这两个三角形的边长比必须相同。因此，y'/near 必须等于 y/z。求解 y' 得到 (y/z)*near，或 y' = (y*near)/z。请注意，对于特定场景，near 是一个常数，而对于场景中的每个顶点，y 和 z 是不同的。使用相同的逻辑，x' = (x*near)/z。

<center>
  <img src="/8/perspective_divide.png" />
</center>

总而言之，我们可以用这样的乘法和除法计算 3D 顶点在 2D 观察窗口中的位置：
```js
x' = (x*near)/z
y' = (y*near)/z
```

准确地说，由于摄像机前面顶点的所有 z 值都是负数，并且 z 的值被视为距离，因此我们需要对 z 的值取反。
```js
x' = (x*near)/(-z)
y' = (y*near)/(-z)
```

但是我们有一个问题。 4×4 变换矩阵是项的线性组合。也就是说，我们可以进行 a*x + b*y + c*z + d 之类的计算，但不能进行 a*x/z + ... 之类的计算，其中顶点的 x 和 z 分量值用于单项。但是我们有一个使用齐次坐标的解决方案。请记住，定义为 (x,y,z,w) 的顶点定义了 3D 空间中点 (x/w, y/w, z/w) 的位置。通常 w 分量等于 1 并且 (x,y,z) 值正是 (x,y,z)。但是要实现透视除法，我们可以将 w 值设置为除数 (-z)。这将上述计算分为两部分。矩阵变换将执行乘法。在矩阵乘法之后的后处理步骤将执行齐次除法。

为了在透视计算中执行乘法，我们可以使用这个矩阵变换：

```html
┌                ┐   ┌   ┐   ┌    ┐ Eq3
│ near 0    0  0 │   | x |   | x' |
| 0    near 0  0 | * | y | = | y' |
| 0    0    1  0 |   | z |   | z' |
| 0    0    0  1 |   | w |   | w' |
└                ┘   └   ┘   └    ┘
```

要将除数 (-z) 转换为 w 值，我们可以使用以下变换：
```html
┌          ┐   ┌   ┐   ┌    ┐ Eq4
│ 1 0 0  0 │   | x |   | x' |
| 0 1 0  0 | * | y | = | y' |
| 0 0 1  0 |   | z |   | z' |
| 0 0 -1 1 |   | w |   | w' |
└          ┘   └   ┘   └    ┘
```

很容易证明这些可以组合成这个单一的变换矩阵，它执行我们的透视计算和除法设置：

```html
┌                 ┐   ┌   ┐   ┌    ┐ Eq5
│ near 0     0  0 │   | x |   | x' |
| 0    near  0  0 | * | y | = | y' |
| 0    0     1  0 |   | z |   | z' |
| 0    0    -1  1 |   | w |   | w' |
└                 ┘   └   ┘   └    ┘
```

图形管道被设计为期望 w 组件中的透视除数。在将顶点的值传递到其余阶段之前，管道总是计算 (x/w, y/w, z/w)。

#### 将视图窗口缩放到 (-1,1) 到 (+1,+1)

图形管道中的后续阶段要求将 2D 观察窗口标准化为 (-1,-1) 到 (+1,+1) 之间的值。我们需要将 x 和 y 值缩放为 2×2 正方形。这可以通过基于简单比率的比例因子轻松完成：2/currentSize。方程和得到的矩阵变换是：
```js
scale_x = 2.0 / (right - left);
scale_y = 2.0 / (top - bottom);
```

```html
┌                                    ┐   ┌   ┐   ┌    ┐ Eq 6
│ 2/(right-left) 0               0 0 │   | x |   | x' |
| 0              2/(top-bottom)  0 0 | * | y | = | y' |
| 0              0               1 0 |   | z |   | z' |
| 0              0               0 1 |   | w |   | w' |
└                                    ┘   └   ┘   └    ┘
```

#### 将深度（z 值）映射到 (-1,+1)

我们已经计算了 2D 查看窗口中顶点的正确位置，但我们没有更改 z 分量。我们不能丢弃 z 值；它告诉我们顶点和相机之间的距离，这使我们能够确定哪些对象在其他对象的前面。我们可以轻松地在 (-near,-far) 到 (-1,+1) 的范围之间进行线性映射。但是，浮点数在处理时会出现舍入误差。在图形应用程序中，有时 0.1234568 和 0.1234567 之间的差异会对渲染产生视觉影响。我们希望对靠近相机的值使用更高的精度，而对远离相机的顶点使用更低的精度。这意味着我们想要 (-near,-far) 和 (-1,+1) 之间的非线性映射。

用于映射的非线性方程是 c1/-z + c2，其中 c1 和 c2 是根据范围 (-near,-far) 计算的常数。当 z = -near 时，方程必须计算 -1。当 z = -far 时，方程必须计算 +1。这给了我们两个方程来求解 c1 和 c2。

```js
-1 = c1/-(-near) + c2
+1 = c1/-(-far)  + c2
```

使用一点代数，我们得到
```js
c1 = 2*far*near / (near - far)
c2 = (far + near) / (far - near)
```

在我们继续之前，让我们考虑一个例子。假设 near = 2.0 和 far = 40。这意味着 z 分量值介于 -2 和 -40 之间的顶点将包含在裁剪体积中。右侧是 z 值列表及其与范围 (-1,+1) 的对应映射。下面还有这些值的图。请注意 -2 和 -3.8 之间的 z 值占用了剪裁量值的一半（-1.0、0.0）！这绝对是非线性的！

<center>
  <img src="/8/non_linear_mapping.png" />
</center>

但是，请坚持住! 我们遇到了与透视计算相同的问题! 你不能把像c1/-z+c2这样的项放进一个变换矩阵中。因此，我们使用与透视除法相同的技巧--我们将除法推迟到变换后的同质除法步骤。我们可以这样写映射方程：c1/-z + c2*(-z)/(-z)，相当于(c1 + c2*(-z))/(-z)。让我们重新排列这些条款以符合我们的变换矩阵格式：(-c2*z + c1)/(-z)。我们可以把这个方程的上半部分放在我们的矩阵变换中，让同分法来处理以后的除法问题。

从 (-near,-far) 到 (-1,+1) 的映射:

| 顶点 z | z在剪裁体积中 |
| --   | --      |
| -2.0 | -1.0000 |
| -3.0 | -0.2982 |
| -4.0 | 0.0526  |
| -5.0 | 0.2632  |
| -6.0 | 0.4035  |
| -8.0 | 0.5789  |
|-10.0 | 0.6842  |
|-12.0 | 0.7544  |
|-14.0 | 0.8045  |
|-16.0 | 0.8421  |
|-18.0 | 0.8713  |
|-20.0 | 0.8947  |
|-25.0 | 0.9368  |
|-30.0 | 0.9649  |
|-35.0 | 0.9850  |
|-40.0 | 1.0000  |


```html
┌            ┐   ┌   ┐   ┌    ┐ Eq7
│ 1 0   0  0 │   | x |   | x' |
| 0 1   0  0 | * | y | = | y' |
| 0 0 -c2 c1 |   | z |   | z' |
| 0 0  -1  1 |   | w |   | w' |
└            ┘   └   ┘   └    ┘
```

请注意，我们需要在w仍为1.0时进行这一转换。

#### 切换坐标系

最后一步是调换z轴的方向以匹配剪切体积的方向。然而，我们不需要这样做，因为当我们把Z值映射到一个非线性范围时，新的范围是-1到+1，这有效地转换了Z轴的方向。

#### 构建前瞻性投影变换

 让我们把上述所有的概念放在一个单一的透视变换矩阵中。我们把步骤列在下面，这样你就可以把每个步骤与它的单独变换相匹配。然而，我们需要稍微修改一下，以考虑到这些变换矩阵的组合。步骤2和3都需要使w等于（-z）。我们不想做这两次，所以我们删除了透视变换中的-1项。此外，我们不需要调换坐标轴的方向，因为当我们将z值映射到(-1,+1)时，这些值被映射翻转了。最后，我们对深度值的缩放进行了重新排序，以确保在w分量为1.0时进行缩放。

1. 将平截头体的顶点平移到原点。 （黄色矩阵）
2. 将深度值 (z) 缩放到标准化范围 (-1,+1)（并设置除以 (-z)）。 （紫色矩阵）
3. 执行透视计算。 （灰色矩阵）
4. 将查看窗口中的 2D (x',y') 值缩放为 2×2 单位正方形； (-1,-1) 到 (+1,+1)。 （青色矩阵）

<center>
  <img src="/8/eq8.png" />
</center>

如果你从右到左点击上面方程中的乘法符号，你可以看到在每一步转换中对（x,y,z,w）顶点的变化进展。

如果您简化矩阵项并将方程替换为 c1 和 c2，您将得到以下转换：

```html
┌                                                                                                   ┐ Eq9
│ 2*near/(right-left)  0                    0                       -near*(right+left)/(right-left) │ 
| 0                    2*near/(top-bottom)  0                       -near*(top+bottom)/(top-bottom) |
| 0                    0                    -(far+near)/(far-near)  2*far*near/(near-far)           |
| 0                    0                    -1                      0                               |
└                                                                                                   ┘
```

你可能永远不会实现代码来创建一个透视投影。它已经在learn_wegbl_matrix.js代码文件中为你实现了。那么，通过上述所有的讨论，有什么价值呢？计算机图形学中的许多操作都是由变换矩阵完成的。如果你能掌握创造变换组合的艺术，你就能创造出惊人的计算机图形程序。前面的讨论希望能帮助你从连锁矩阵变换的角度思考问题，以实现一个特定的目标。

### 比较createPerspective()与createFrustum()。

让我们比较一下函数 createPerspective() 和 createFrustum()

它们有何相似之处？
- 两者都创建了透视变换矩阵

它们有何不同？
- 它们需要不同的参数来定义视锥体观看量。
- createPerspective() 函数只允许视锥体以全局原点为中心。
- createFrustum 函数允许视锥体沿 X 或 Y 轴从全局原点偏移。

为了演示函数的等价性，以下两个示例展示了如何使用一个函数来实现另一个函数。
```js
function createPerspectiveUsingFrustum (fovy, aspect, near, far) {

  var top, bottom, left, right;

  top = near * Math.tan(toRadians(fovy)/2);
  bottom = -top;
  right = top * aspect;
  left = -right;

  return createFrustum(left, right, bottom, top, near, far);
}

function createFrustumUsingPerspective (left, right, bottom, top, near, far) {
  var fovy, aspect;

  fovy = 2 * toDegrees(Math.atan2(top, near));
  if (-left === right && -bottom === top ) {
    aspect = right / top; // width / height

    return createPerspective(fovy, aspect, near, far);
  }
}
```

### 总结

当您将透视投影分解为其基本组成部分时，很容易理解数学是如何完成所需的操作的。如果您想了解复杂的转换，请将它们分解为基本步骤。

从根本上说，透视投影会根据每个顶点到相机的距离来改变每个顶点的 x 和 y 值。它还为裁剪准备顶点。