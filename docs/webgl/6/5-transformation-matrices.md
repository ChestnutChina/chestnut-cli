## 转换矩阵

前三课描述了可以应用于模型的基本变换：平移、缩放和旋转。这些变换可以被组合起来产生复杂的运动。但我们需要一种简单而有效的方法来组合这些变换。解决办法就是矩阵!

本课将回顾矩阵数学的基础知识，并告诉你如何使用矩阵来组合变换。矩阵几乎用于所有的计算机图形计算，包括相机操作和将你的3D场景投影到2D观察窗口。因此，这是你需要掌握的一个关键部分的材料。

本教程的目的不是为这些概念提供数学证明，而是让你在如何使用矩阵数学来创建计算机图形方面打下坚实的基础。如果你希望接受正规的矩阵数学教育，我建议你学习卡恩学院的[线性代数课程](https://www.khanacademy.org/math/linear-algebra)，但掌握计算机图形学并不需要这种水平的专业知识。

### 矩阵基础

方程组可以通过将方程的系数与变量分开来写成矩阵格式。让我们把旋转的一般方程写成矩阵形式。请注意，x、y和z值是我们的 "变量"，fn值是方程项的 "系数"。为了操作计算机图形场景的图形模型，我们将通过选择适当的fn值来创建变换，然后将变换应用于模型的每个顶点。fn值在渲染一帧动画时是恒定的，但在下一帧动画中通常会发生变化。

方程：
```html
f1*x + f2*y + f3*z = x'
f4*x + f5*y + f6*z = y'
f7*x + f8*y + f9*z = z'
```

在矩阵格式中看起来像这样：

```html
┌          ┐   ┌   ┐   ┌   ┐
│ f1 f2 f3 │   | x |   | x'|  Eq1
│ f4 f5 f6 | * | y | = | y'|
| f7 f8 f9 │   | z |   | z'|
└          ┘   └   ┘   └   ┘ 
```

这些教程中介绍的矩阵方程可以通过点击方程中的运算符号来执行。现在就试试吧，点击上面方程中的乘法符号。一个新版本的方程将显示在原方程的下方，其中运算符号前后的矩阵已被一个单一的矩阵所取代，该矩阵就是运算的结果。矩阵的乘法过程如下：结果中的每个元素都是通过取左边矩阵的相应行和右边矩阵的相应列，然后将各个相应的元素相乘，再将这些项相加计算出来的。如果你把光标放在新显示的矩阵中的任何元素上，用于计算该项的相应行和列就会在原矩阵中突出显示。如果矩阵中包含数字而不是符号，也许会更容易直观地看到这些问题。通过点击乘法符号进行下面的矩阵乘法，然后将鼠标悬停在结果的每项上。

```html
┌       ┐   ┌   ┐   ┌   ┐
│ 1 0 3 │   | x |   | x'|  Eq2
│ 5 2 0 | * | y | = | y'|
| 6 1 0 │   | z |   | z'|
└       ┘   └   ┘   └   ┘ 
```

用来计算每个项的方程故意显示在结果中，以便你能看到每个值的来源。选择方程右边的"-"按钮，可以将每个项减少到其最简单的计算值。请在这些教程中使用这一功能，仔细研究矩阵的工作原理。如果你点击方程中的等号，方程的每条边都会被还原成最简单的形式。右边的 "X "按钮将从网页上删除生成的方程。


### 矩阵格式的基本变换

从上一课中你了解到，缩放变换是通过像这样的顶点分量相乘来进行的，其中（x,y,z）是一个顶点，（x',y'z'）是一个变换的顶点:
```html
x * sx = x'
y * sy = y'
z * sz = z'
```
这些比例方程可以用矩阵格式这样写:

```html
┌         ┐   ┌   ┐   ┌   ┐
│ sx 0  0 │   | x |   | x'|  Eq3
│ 0  sy 0 | * | y | = | y'|
| 0  0  sz│   | z |   | z'|
└         ┘   └   ┘   └   ┘ 
```

将矩阵相乘，还原方程，以看到等价关系。把这么简单的方程用矩阵的方式变得更复杂，可能看起来很疯狂。但你很快就会看到矩阵的力量。

旋转变换可以很容易地用矩阵格式来写。让我们把关于Z轴的旋转方程写成矩阵格式:
```html
x * cos(angle) + y * -sin(angle) = x'
x * sin(angle) + y *  cos(angle) = y'
                               z = z'
```

```html
┌                           ┐   ┌   ┐   ┌   ┐
│ cos(angle)  -sin(angle) 0 │   | x |   | x'|  Eq4
│ sin(angle)  cos(angle)  0 | * | y | = | y'|
|     0           0       1 │   | z |   | z'|
└                           ┘   └   ┘   └   ┘ 
```

现在我们来到了难点--平移。注意，在之前的每个例子中，每个顶点分量的转换都是原始x、y和z值的某种组合。但是对于平移，我们只是想给每个分量增加一个值。到目前为止，我们所使用的矩阵没有办法做到这一点。所以我们需要一个更大的矩阵。我们不使用3乘以3的矩阵，而是使用4乘以4的，像这样。

平移方程为：
```html
x + tx = x'
y + ty = y'
z + tz = z'
```

矩阵格式的等效方程为：
```html
┌            ┐   ┌   ┐   ┌   ┐
│ 1  0  0  0 │   | x |   | x'|  Eq5
│ 0  1  0  0 | * | y | = | y'|
| 0  0  1  0 |   | z |   | z'|
| 0  0  0  1 │   | 1 |   | 1 |
└            ┘   └   ┘   └   ┘ 
```

让我们对这个矩阵乘法做一些观察:
- (x,y,z)列向量末尾的附加分量1保证了偏移量(tx, ty, tz)不会改变。
- 对角线下的1保证原始（x,y,z）值包含在结果中不变。
- 变换矩阵的最后一行（0,0,0,1）保证（x,y,z）值末尾的1分量在结果中保持为1。

问题是什么？我们真的需要变换矩阵中的最后一行吗？我们可以这样做吗？

```html
┌             ┐   ┌   ┐   ┌   ┐
│ 1  0  0  tx │   | x |   | x'|  Eq6
│ 0  1  0  ty | * | y | = | y'|
| 0  0  1  tz |   | z |   | z'|
└             ┘   | 1 |   └   ┘
                  └   ┘
```

从纯数学的角度来看，是的，你可以。然而，我们的目标是创建一个单一的、一致的格式来应用一系列的变换。此外，我们需要撤销（或逆转）变换的能力，这就要求我们的变换矩阵是方形的。因此，转换矩阵中的第4行是必需的。

最后加在顶点上的额外数值，即尾部的1，被称为同质坐标。标准惯例是将其称为w分量。因此，一个顶点在同质坐标中看起来像（x,y,z,w）。w分量的用处不仅仅是平移，我们将在以后的课程中讨论这些用途。但是现在，请注意，w组件实现（和控制）平移。对于一个顶点，我们总是希望w分量为1。然而，请记住，矢量有一个大小和方向，但没有位置。矢量不能被平移! 当我们用同质坐标表示一个矢量时，w值需要为零！因为我们很少存储同质坐标。由于我们很少在内存中存储同质分量以减少内存的使用，所以当需要时你必须添加同质分量。请记住。

- 对于顶点使用(x,y,z,1)，它允许缩放、旋转和平移。
- 对于矢量使用\<dx,dy,dz,0>，它允许缩放和旋转（但不允许平移）。

把这一切放在一起，我们就有了以下一致的方式来执行我们的三个基本转换。

缩放：
```html
┌              ┐   ┌   ┐   ┌   ┐
│ sx  0  0   0 │   | x |   | x'|  Eq7
│ 0  sy  0   0 | * | y | = | y'|
| 0   0  sz  0 |   | z |   | z'|
| 0   0  0   1 │   | 1 |   | 1 |
└              ┘   └   ┘   └   ┘ 
```

平移:
```html
┌             ┐   ┌   ┐   ┌   ┐
│ 1  0  0  tx │   | x |   | x'|  Eq8
│ 0  1  0  ty | * | y | = | y'|
| 0  0  1  tz |   | z |   | z'|
| 0  0  0  1  │   | 1 |   | 1 |
└             ┘   └   ┘   └   ┘ 
```

绕 Z 轴旋转角度：
```html
┌                               ┐   ┌   ┐   ┌   ┐
│ cos(angle)  -sin(angle)  0  0 │   | x |   | x'|  Eq9
│ sin(angle)  cos(angle)   0  0 | * | y | = | y'|
| 0               0        1  0 |   | z |   | z'|
| 0               0        0  1 │   | 1 |   | 1 |
└                               ┘   └   ┘   └   ┘ 
```

绕 Y 轴旋转角度：
```html
┌                              ┐   ┌   ┐   ┌   ┐
│ cos(angle)  0  sin(angle)  0 │   | x |   | x'|  Eq10
│     0       1      0       0 | * | y | = | y'|
| -sin(angle) 0  cos(angle)  0 |   | z |   | z'|
| 0           0      0       1 │   | 1 |   | 1 |
└                              ┘   └   ┘   └   ┘ 
```

绕 X 轴旋转角度：
```html
┌                              ┐   ┌   ┐   ┌   ┐
│ 1      0            0      0 │   | x |   | x'|  Eq11
│ 0  cos(angle)  -sin(angle) 0 | * | y | = | y'|
| 0  sin(angle)  cos(angle)  0 |   | z |   | z'|
| 0      0           0       1 │   | 1 |   | 1 |
└                              ┘   └   ┘   └   ┘ 
```

围绕定义为\<ux,uy,uz> 的任何轴旋转角度度数：

让我们通过结合我们已经创建的变换，推导出一个围绕任何轴旋转的变换。这将给你一个例子，说明基本的变换如何能够被组合成更复杂的变换。如果我们想围绕<ux, uy, uz>定义的轴进行旋转，那么我们可以通过执行以下的变换序列来实现。

1. 围绕Z轴旋转，将矢量\<ux, uy, uz>放在Z-X平面内。让我们称这个新的矢量为\<ux', uy', uz'>。
2. 然后围绕Y轴旋转，将\<ux', uy', uz'>沿X轴放置。
3. 然后围绕X轴旋转到所需的角度。
4. 然后围绕Y轴旋转，将\<ux', uy', uz'>放回它的原始位置。
5. 然后围绕Z轴旋转，将\<ux', uy, uz>放回其原来的位置。

这一系列的5个旋转将提供一个模型围绕\<ux,uy,uz>轴旋转的视觉效果。但是我们不希望为每个顶点反复做这5个变换。我们想要一个单一的变换来产生我们想要的视觉运动。我们可以通过在开始渲染前将5个矩阵相乘来实现这一目的，然后使用一个单一的变换矩阵来执行所需的旋转。为了明确这个想法，让我们按照指定的顺序执行上面的5个变换。这个顺序很关键，因为如果你改变这个顺序，你会得到一个非常不同的结果。

我们需要计算2个旋转的角度，使旋转轴与X轴对齐。让i作为第一步的角度，j作为第二步的角度，k作为第三步的角度。并让我们用s()和c()来表示正弦和余弦函数。变换的结果是这样的:

```html
┌                   ┐   ┌                  ┐   ┌                ┐   ┌                 ┐   ┌                ┐   ┌   ┐   ┌    ┐
│ c(-i)  -s(-i) 0 0 │   | c(-j)  0 s(-j) 0 |   | 1  0    0    0 |   | c(j)  0 s(j)  0 |   | c(i) -s(i) 0 0 |   | x |   | x' |  Eq12
│ s(-i)  c(-i)  0 0 | * | 0      1 0     0 | * | 1 c(k) -s(k) 0 | * | 0     1  0    0 | * | s(i) c(i)  0 0 | * | y | = | y' |
| 0      0      1 0 |   | -s(-j) 0 c(-j) 0 |   | 0 s(k) c(k)  0 |   | -s(j) 0 c(j)  0 |   | 0     0    1 0 |   | z |   | z' |
| 0      0      0 1 │   | 0      0 0     1 |   | 0  0    0    1 |   | 0     0  0    1 |   | 0     0    0 1 |   | 1 |   | 1  |
└                   ┘   └                  ┘   └                ┘   └                 ┘   └                ┘   └   ┘   └    ┘ 
```

执行上述方程中的矩阵乘法，看看单一变换等于什么。请注意，得出的答案是以sin和cos函数为单位的，因为方程中不包含具体的数值，但在特定的情况下，你会有一个4乘4的单一矩阵，其中有16个数值，可以执行你所需要的变换。如果你要转换的模型包含10,000个顶点，将你的复杂转换减少到一个单一的4乘4矩阵，可以节省大量的计算量。

应该注意的是，围绕轴<ux, uy, uz>的旋转可以通过合并上述方程中的同类项，用更简单的方程计算。对于那些常见的操作，如围绕特定轴的旋转，在将其编入算法之前，计算被简化为最简单的形式。但是对于一般情况，复杂的运动将通过形成一系列的4x4矩阵变换并将它们组合成一个单一的变换矩阵来创建。

让我们来看看矩阵的一些基本属性。

### 矩阵的基本属性 - 顺序很重要!

矩阵代表一个方程组。因此，只有一小部分操作是有意义的。基本操作是乘法。我们在上面的讨论中定义了矩阵的乘法方式。需要理解的是，乘法的顺序很重要。一般来说，**M1*M2 !=M2*M1**。用下面的例子做实验。