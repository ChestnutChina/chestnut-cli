## 转换矩阵

前三课描述了可以应用于模型的基本变换：平移、缩放和旋转。这些变换可以被组合起来产生复杂的运动。但我们需要一种简单而有效的方法来组合这些变换。解决办法就是矩阵!

本课将回顾矩阵数学的基础知识，并告诉你如何使用矩阵来组合变换。矩阵几乎用于所有的计算机图形计算，包括相机操作和将你的3D场景投影到2D观察窗口。因此，这是你需要掌握的一个关键部分的材料。

本教程的目的不是为这些概念提供数学证明，而是让你在如何使用矩阵数学来创建计算机图形方面打下坚实的基础。如果你希望接受正规的矩阵数学教育，我建议你学习卡恩学院的[线性代数课程](https://www.khanacademy.org/math/linear-algebra)，但掌握计算机图形学并不需要这种水平的专业知识。

### 矩阵基础

方程组可以通过将方程的系数与变量分开来写成矩阵格式。让我们把旋转的一般方程写成矩阵形式。请注意，x、y和z值是我们的 "变量"，fn值是方程项的 "系数"。为了操作计算机图形场景的图形模型，我们将通过选择适当的fn值来创建变换，然后将变换应用于模型的每个顶点。fn值在渲染一帧动画时是恒定的，但在下一帧动画中通常会发生变化。

方程：
```html
f1*x + f2*y + f3*z = x'
f4*x + f5*y + f6*z = y'
f7*x + f8*y + f9*z = z'
```

在矩阵格式中看起来像这样：

```html
┌          ┐   ┌   ┐   ┌   ┐
│ f1 f2 f3 │   | x |   | x'|  Eq1
│ f4 f5 f6 | * | y | = | y'|
| f7 f8 f9 │   | z |   | z'|
└          ┘   └   ┘   └   ┘ 
```

这些教程中介绍的矩阵方程可以通过点击方程中的运算符号来执行。现在就试试吧，点击上面方程中的乘法符号。一个新版本的方程将显示在原方程的下方，其中运算符号前后的矩阵已被一个单一的矩阵所取代，该矩阵就是运算的结果。矩阵的乘法过程如下：结果中的每个元素都是通过取左边矩阵的相应行和右边矩阵的相应列，然后将各个相应的元素相乘，再将这些项相加计算出来的。如果你把光标放在新显示的矩阵中的任何元素上，用于计算该项的相应行和列就会在原矩阵中突出显示。如果矩阵中包含数字而不是符号，也许会更容易直观地看到这些问题。通过点击乘法符号进行下面的矩阵乘法，然后将鼠标悬停在结果的每项上。

```html
┌       ┐   ┌   ┐   ┌   ┐
│ 1 0 3 │   | x |   | x'|  Eq2
│ 5 2 0 | * | y | = | y'|
| 6 1 0 │   | z |   | z'|
└       ┘   └   ┘   └   ┘ 
```

用来计算每个项的方程故意显示在结果中，以便你能看到每个值的来源。选择方程右边的"-"按钮，可以将每个项减少到其最简单的计算值。请在这些教程中使用这一功能，仔细研究矩阵的工作原理。如果你点击方程中的等号，方程的每条边都会被还原成最简单的形式。右边的 "X "按钮将从网页上删除生成的方程。


### 矩阵格式的基本变换

从上一课中你了解到，缩放变换是通过像这样的顶点分量相乘来进行的，其中（x,y,z）是一个顶点，（x',y'z'）是一个变换的顶点:
```html
x * sx = x'
y * sy = y'
z * sz = z'
```
这些比例方程可以用矩阵格式这样写:

```html
┌         ┐   ┌   ┐   ┌   ┐
│ sx 0  0 │   | x |   | x'|  Eq3
│ 0  sy 0 | * | y | = | y'|
| 0  0  sz│   | z |   | z'|
└         ┘   └   ┘   └   ┘ 
```

将矩阵相乘，还原方程，以看到等价关系。把这么简单的方程用矩阵的方式变得更复杂，可能看起来很疯狂。但你很快就会看到矩阵的力量。

旋转变换可以很容易地用矩阵格式来写。让我们把关于Z轴的旋转方程写成矩阵格式:
```html
x * cos(angle) + y * -sin(angle) = x'
x * sin(angle) + y *  cos(angle) = y'
                               z = z'
```

```html
┌                           ┐   ┌   ┐   ┌   ┐
│ cos(angle)  -sin(angle) 0 │   | x |   | x'|  Eq4
│ sin(angle)  cos(angle)  0 | * | y | = | y'|
|     0           0       1 │   | z |   | z'|
└                           ┘   └   ┘   └   ┘ 
```

现在我们来到了难点--平移。注意，在之前的每个例子中，每个顶点分量的转换都是原始x、y和z值的某种组合。但是对于平移，我们只是想给每个分量增加一个值。到目前为止，我们所使用的矩阵没有办法做到这一点。所以我们需要一个更大的矩阵。我们不使用3乘以3的矩阵，而是使用4乘以4的，像这样。

平移方程为：
```html
x + tx = x'
y + ty = y'
z + tz = z'
```

矩阵格式的等效方程为：
```html
┌            ┐   ┌   ┐   ┌   ┐
│ 1  0  0  0 │   | x |   | x'|  Eq5
│ 0  1  0  0 | * | y | = | y'|
| 0  0  1  0 |   | z |   | z'|
| 0  0  0  1 │   | 1 |   | 1 |
└            ┘   └   ┘   └   ┘ 
```

让我们对这个矩阵乘法做一些观察:
- (x,y,z)列向量末尾的附加分量1保证了偏移量(tx, ty, tz)不会改变。
- 对角线下的1保证原始（x,y,z）值包含在结果中不变。
- 变换矩阵的最后一行（0,0,0,1）保证（x,y,z）值末尾的1分量在结果中保持为1。

问题是什么？我们真的需要变换矩阵中的最后一行吗？我们可以这样做吗？

```html
┌             ┐   ┌   ┐   ┌   ┐
│ 1  0  0  tx │   | x |   | x'|  Eq6
│ 0  1  0  ty | * | y | = | y'|
| 0  0  1  tz |   | z |   | z'|
└             ┘   | 1 |   └   ┘
                  └   ┘
```

从纯数学的角度来看，是的，你可以。然而，我们的目标是创建一个单一的、一致的格式来应用一系列的变换。此外，我们需要撤销（或逆转）变换的能力，这就要求我们的变换矩阵是方形的。因此，转换矩阵中的第4行是必需的。

最后加在顶点上的额外数值，即尾部的1，被称为同质坐标。标准惯例是将其称为w分量。因此，一个顶点在同质坐标中看起来像（x,y,z,w）。w分量的用处不仅仅是平移，我们将在以后的课程中讨论这些用途。但是现在，请注意，w组件实现（和控制）平移。对于一个顶点，我们总是希望w分量为1。然而，请记住，矢量有一个大小和方向，但没有位置。矢量不能被平移! 当我们用同质坐标表示一个矢量时，w值需要为零！因为我们很少存储同质坐标。由于我们很少在内存中存储同质分量以减少内存的使用，所以当需要时你必须添加同质分量。请记住。

- 对于顶点使用(x,y,z,1)，它允许缩放、旋转和平移。
- 对于矢量使用\<dx,dy,dz,0>，它允许缩放和旋转（但不允许平移）。

把这一切放在一起，我们就有了以下一致的方式来执行我们的三个基本转换。

缩放：
```html
┌              ┐   ┌   ┐   ┌   ┐
│ sx  0  0   0 │   | x |   | x'|  Eq7
│ 0  sy  0   0 | * | y | = | y'|
| 0   0  sz  0 |   | z |   | z'|
| 0   0  0   1 │   | 1 |   | 1 |
└              ┘   └   ┘   └   ┘ 
```

平移:
```html
┌             ┐   ┌   ┐   ┌   ┐
│ 1  0  0  tx │   | x |   | x'|  Eq8
│ 0  1  0  ty | * | y | = | y'|
| 0  0  1  tz |   | z |   | z'|
| 0  0  0  1  │   | 1 |   | 1 |
└             ┘   └   ┘   └   ┘ 
```

绕 Z 轴旋转角度：
```html
┌                               ┐   ┌   ┐   ┌   ┐
│ cos(angle)  -sin(angle)  0  0 │   | x |   | x'|  Eq9
│ sin(angle)  cos(angle)   0  0 | * | y | = | y'|
| 0               0        1  0 |   | z |   | z'|
| 0               0        0  1 │   | 1 |   | 1 |
└                               ┘   └   ┘   └   ┘ 
```

绕 Y 轴旋转角度：
```html
┌                              ┐   ┌   ┐   ┌   ┐
│ cos(angle)  0  sin(angle)  0 │   | x |   | x'|  Eq10
│     0       1      0       0 | * | y | = | y'|
| -sin(angle) 0  cos(angle)  0 |   | z |   | z'|
| 0           0      0       1 │   | 1 |   | 1 |
└                              ┘   └   ┘   └   ┘ 
```

绕 X 轴旋转角度：
```html
┌                              ┐   ┌   ┐   ┌   ┐
│ 1      0            0      0 │   | x |   | x'|  Eq11
│ 0  cos(angle)  -sin(angle) 0 | * | y | = | y'|
| 0  sin(angle)  cos(angle)  0 |   | z |   | z'|
| 0      0           0       1 │   | 1 |   | 1 |
└                              ┘   └   ┘   └   ┘ 
```

围绕定义为\<ux,uy,uz> 的任何轴旋转角度度数：

让我们通过结合我们已经创建的变换，推导出一个围绕任何轴旋转的变换。这将给你一个例子，说明基本的变换如何能够被组合成更复杂的变换。如果我们想围绕\<ux, uy, uz>定义的轴进行旋转，那么我们可以通过执行以下的变换序列来实现。

1. 围绕Z轴旋转，将矢量\<ux, uy, uz>放在Z-X平面内。让我们称这个新的矢量为\<ux', uy', uz'>。
2. 然后围绕Y轴旋转，将\<ux', uy', uz'>沿X轴放置。
3. 然后围绕X轴旋转到所需的角度。
4. 然后围绕Y轴旋转，将\<ux', uy', uz'>放回它的原始位置。
5. 然后围绕Z轴旋转，将\<ux', uy, uz>放回其原来的位置。

这一系列的5个旋转将提供一个模型围绕\<ux,uy,uz>轴旋转的视觉效果。但是我们不希望为每个顶点反复做这5个变换。我们想要一个单一的变换来产生我们想要的视觉运动。我们可以通过在开始渲染前将5个矩阵相乘来实现这一目的，然后使用一个单一的变换矩阵来执行所需的旋转。为了明确这个想法，让我们按照指定的顺序执行上面的5个变换。这个顺序很关键，因为如果你改变这个顺序，你会得到一个非常不同的结果。

我们需要计算2个旋转的角度，使旋转轴与X轴对齐。让i作为第一步的角度，j作为第二步的角度，k作为第三步的角度。并让我们用s()和c()来表示正弦和余弦函数。变换的结果是这样的:

```html
┌                   ┐   ┌                  ┐   ┌                ┐   ┌                 ┐   ┌                ┐   ┌   ┐   ┌    ┐
│ c(-i)  -s(-i) 0 0 │   | c(-j)  0 s(-j) 0 |   | 1  0    0    0 |   | c(j)  0 s(j)  0 |   | c(i) -s(i) 0 0 |   | x |   | x' |  Eq12
│ s(-i)  c(-i)  0 0 | * | 0      1 0     0 | * | 1 c(k) -s(k) 0 | * | 0     1  0    0 | * | s(i) c(i)  0 0 | * | y | = | y' |
| 0      0      1 0 |   | -s(-j) 0 c(-j) 0 |   | 0 s(k) c(k)  0 |   | -s(j) 0 c(j)  0 |   | 0     0    1 0 |   | z |   | z' |
| 0      0      0 1 │   | 0      0 0     1 |   | 0  0    0    1 |   | 0     0  0    1 |   | 0     0    0 1 |   | 1 |   | 1  |
└                   ┘   └                  ┘   └                ┘   └                 ┘   └                ┘   └   ┘   └    ┘ 
```

执行上述方程中的矩阵乘法，看看单一变换等于什么。请注意，得出的答案是以sin和cos函数为单位的，因为方程中不包含具体的数值，但在特定的情况下，你会有一个4乘4的单一矩阵，其中有16个数值，可以执行你所需要的变换。如果你要转换的模型包含10,000个顶点，将你的复杂转换减少到一个单一的4乘4矩阵，可以节省大量的计算量。

应该注意的是，围绕轴\<ux, uy, uz>的旋转可以通过合并上述方程中的同类项，用更简单的方程计算。对于那些常见的操作，如围绕特定轴的旋转，在将其编入算法之前，计算被简化为最简单的形式。但是对于一般情况，复杂的运动将通过形成一系列的4x4矩阵变换并将它们组合成一个单一的变换矩阵来创建。

让我们来看看矩阵的一些基本属性。

### 矩阵的基本属性 - 顺序很重要!

矩阵代表一个方程组。因此，只有一小部分操作是有意义的。基本操作是乘法。我们在上面的讨论中定义了矩阵的乘法方式。需要理解的是，乘法的顺序很重要。一般来说，**M1*M2 !=M2*M1**。用下面的例子做实验。

```html
┌      ┐   ┌      ┐    ┌       ┐   ┌      ┐   Eq13
│ 2  4 │   | -4 3 |    | -4  3 |   | 2  4 |
│ 5 -3 │ * | -4 8 | != | -4  8 | * | 5 -3 |
└      ┘   └      ┘    └       ┘   └      ┘
```

从计算机图形学的角度来看，很容易理解矩阵顺序的重要性。例如，从物理上看，采取一些物体，假设它位于原点，并对它进行这些变换:

1. 将它在X轴上向下移动2个单位。
2. 然后将它围绕Z轴旋转90度。

现在，按相反的顺序进行转换:

1. 将物体围绕Z轴旋转90度。
2. 然后在X轴上向下移动2个单位。

该物体最终会出现在一个完全不同的地方!

让我们以矩阵的形式进行这些转换。下面的方程将一个物体在X轴上移动2个单位，然后围绕Z轴旋转90度:

```html
┌                         ┐   ┌            ┐    ┌   ┐   ┌    ┐   Eq14
│ cos(90)  -sin(90)  0  0 │   | 1  0  0  2 |    | x |   | x' |
│ sin(90)   cos(90)  0  0 │ * | 0  1  0  0 | *  | y | = | y' |
│   0         0      1  0 |   | 0  0  1  0 |    | z |   | z' |
│   0         0      0  1 |   | 0  0  0  1 |    | 1 |   | 1  |
└                         ┘   └            ┘    └   ┘   └    ┘
```

而这个方程先进行旋转，再进行平移:

```html
┌            ┐   ┌                         ┐    ┌   ┐   ┌    ┐   Eq15
│ 1  0  0  2 │   | cos(90)  -sin(90)  0  0 |    | x |   | x' |
│ 0  1  0  0 │ * | sin(90)   cos(90)  0  0 | *  | y | = | y' |
│ 0  0  1  0 |   |   0         0      1  0 |    | z |   | z' |
│ 0  0  0  1 |   |   0         0      0  1 |    | 1 |   | 1  |
└            ┘   └                         ┘    └   ┘   └    ┘
```

将这两个方程相乘并简化，可以看到变换确实是完全不同的! 最接近(x,y,z,1)向量的矩阵是首先发生的变换。然后是其左边的变换，以此类推。因此，你必须在计算中从右到左排列变换的顺序，以得到你想要的变换顺序。

### 单位矩阵和逆矩阵

如果两个矩阵相乘，一个身份矩阵不会改变另一个矩阵的值。这与单个数值乘以1的情况相同。用下面两个例子做实验：

```html
┌            ┐   ┌   ┐   ┌   ┐   Eq16
│ 1  0  0  0 │   | x |   | x |
│ 0  1  0  0 │ * | y | = | y |
│ 0  0  1  0 |   | z |   | z |
│ 0  0  0  1 |   | 1 |   | 1 |
└            ┘   └   ┘   └   ┘
```

```html
┌            ┐   ┌           ┐   ┌           ┐   Eq17
│ 1  0  0  0 │   | 2 -3  5 7 |   | 2 -3  5 7 |
│ 0  1  0  0 │ * | 8 -4  3 2 | = | 8 -4  3 2 |
│ 0  0  1  0 |   | 0  5 -6 5 |   | 0  5 -6 5 |
│ 0  0  0  1 |   | 1  2  3 4 |   | 1  2  3 4 |
└            ┘   └           ┘   └           ┘
```

单位矩阵由大写字母 I 表示。

一个 4×4 矩阵对一组顶点执行变换。通常需要反转转换以恢复原始值。在代数中，撤销加法的方法是减法。例如，通过从两边减去 5 来检查如何将 5 移动到等式的另一边：
```js
x + 5 = x'
x + 5 - 5 = x' - 5
x = x' - 5
```
以类似的方式，撤消乘法的方法是除法（或乘以倒数）。例如，检查乘以 5 的结果如何通过除以 5 移动到等式的另一边。

```js
x * 5 = x'
(x * 5) / 5 = x' / 5
x = x' / 5
x = x' * (1/5)
```

矩阵的除法是通过乘以矩阵逆来执行的。给定一个矩阵 M，如果你将它乘以它的逆矩阵，结果就是单位矩阵。符号 M-1 表示 M 的逆矩阵。矩阵逆矩阵将产生一个单位矩阵，而不管矩阵乘法的顺序如何。那是，
<center>
  <img src="/6/Eq18.png" />
</center>

任意 4×4 矩阵可能有也可能没有逆矩阵。但是，如果您创建一个结合了缩放、旋转和/或平移的变换，则生成的 4×4 矩阵将始终具有逆矩阵。我们将在后面的课程中讨论如何使用矩阵求逆。

矩阵数学遵循与代数相同的简单规则。如果你有一个方程，你必须总是在方程的两边执行相同的操作来保持它的相等性。但是，由于矩阵乘法的顺序很重要，如果您将等式的一侧预乘以矩阵，请确保将等式的另一侧预乘以相同的矩阵。考虑以下等式：

```html
┌   ┐   ┌   ┐    ┌   ┐  Eq19
│ S │ * | T | =  | U |  
└   ┘   └   ┘    └   ┘  
```

在下面对这个方程的操作中，第一个和第二个方程是有效的，而第三个方程是无效的:

```html
┌   ┐   ┌   ┐   ┌   ┐   ┌   ┐   ┌   ┐  Eq20- 是有效的，因为 B 是预乘的
│ B │ * | S | * | T | = | B | * | U |
└   ┘   └   ┘   └   ┘   └   ┘   └   ┘
```

```html
┌   ┐   ┌   ┐   ┌   ┐   ┌   ┐   ┌   ┐  Eq21- 是有效的，因为 B 是后乘的
│ S │ * | T | * | B | = | U | * | B |
└   ┘   └   ┘   └   ┘   └   ┘   └   ┘
```

```html
┌   ┐   ┌   ┐   ┌   ┐   ┌   ┐   ┌   ┐  Eq22- 无效，因为乘法不一致
│ S │ * | T | * | B | = | B | * | U |
└   ┘   └   ┘   └   ┘   └   ┘   └   ┘
```

### 矩阵约定

计算机图形转换的基本问题是它们的顺序。正如我们已经讨论过的，这与矩阵乘法的顺序有关。按照惯例，WebGL（及其衍生的 OpenGL 系统）从右到左对转换进行排序。这是因为我们创建初始方程的方式。我们首先将变换矩阵定位在 (x,y,z,w) 顶点的左侧。还有另一种方法可以执行相同的乘法。您可以将 (x,y,z,w) 顶点放在等式的前面，如下所示：

```html
┌         ┐   ┌            ┐   ┌            ┐   Eq23
│ x y z 1 │ * | 1   0  0 0 |   | x' y' z' 1 | 
└         ┘   | 0   1  0 0 | = └            ┘
              | 0   0  1 0 |   
              | tx ty tz 1 |   
              └            ┘   
```

请注意，上例中的转换矩阵必须将转换值移到矩阵的最后一行。事实上，我们讨论过的每一个变换矩阵（除了缩放），如果你对变换进行后乘法，都会有不同的格式。而且，如果你使用这个惯例，变换是从左到右应用的，而不是从右到左。重要的是，你要选择一个惯例，并一致地使用它。千万不要混合使用这些惯例 在整个教程中，我们将使用WebGL/OpenGL的惯例，即预先将变换乘以顶点。

需要注意的是。在网上搜索，很容易得到关于图形变换的相互矛盾的信息，因为有两种结构变换的方式，即前乘法或后乘法。OpenGL使用前乘法惯例，而微软的Direct3D则使用后乘法惯例。因此，请确保你了解一个网页所假设的惯例，这样你就不会被相互矛盾的信息所迷惑。

### 额外资源

如果你对矩阵数学的理解还很薄弱，学生们推荐了这个数学很有趣的[网站](https://www.mathsisfun.com/algebra/matrix-multiplying.html)。