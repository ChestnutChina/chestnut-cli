## 一个机器人手臂的底座

本课介绍了一个WebGL程序的例子，该程序使用Learn_webgl_matrix JavaScript类来创建和操作变换矩阵。当你渲染一个场景时，有一个预处理步骤来初始化你的上下文，还有单独的步骤来渲染一个单独的帧。我们将分别讨论这两个主要问题。

这个例子将在接下来的几节课中得到加强，所以在进入下一课之前，请确保你理解这个例子。

### 图形管道（评论）


<center>
<img src='/6/graphics_pipeline2.png' />
</center>

我们在以前的课程中讨论过图形管道，但我们需要回顾一下管道的工作原理。管道中的前3个操作是转换，完成以下任务:

1. 模型视图转换。这实际上是两个独立的、不同的操作:
    - 模型转换。将一个模型转化为正确的尺寸、位置和方向。
    - 视图转换。将一个模型转化为在场景摄像机前的正确位置和方向。
2. 投影变换。对一个模型进行变换，将其从三维空间投射到二维观察窗口。
3. 归一化和剪辑变换。对一个模型进行转换，这样如果它不在场景摄像机的视线范围内，它就可以很容易地被丢弃。(这被称为 "剪裁"，因为模型的一部分可能是可见的，而另一部分可能是不可见的）。

重要的是，你要理解以下 "大概念":

- 所有这些变换操作都是由一个4乘4的变换矩阵执行的。
- 你必须始终包括所有这些变换。它们对图形管道都很重要。
- 有太多的细节需要同时讨论所有这些变换。本课将集中讨论模型变换。其他的变换将在以后的课程中全面讲解。(在下面的演示代码中，我们将 "神奇地 "创建一个视图变换和一个投影变换（其中包括归一化和剪辑变换。现在，只需认识到这些变换是需要的）。

通常的做法是将模型、视图和投影变换组合成一个 4×4 变换矩阵，这样顶点着色器只需将每个顶点相乘一次。此演示代码创建了这样一个组合转换。请记住，转换必须从右到左排序。实际上，您开发的每个 WebGL 程序都会创建一个顶点变换矩阵，如下所示：
```html
                  ┌                  ┐   ┌            ┐   ┌              ┐ Eq1
VertexTransform = │ ProjectionMatrix │ * | ViewMatrix | * |  ModelMatrix |
                  └                  ┘   └            ┘   └              ┘
```

### 场景渲染初始化

使用良好的软件开发设计原则，我们创建了一个 JavaScript 类来封装渲染场景所需的功能。该类的构造函数将执行场景初始化。构造函数代码是不在类的子函数内的所有语句。因为我们使用JavaScript“使用严格”；模式下，所有变量和函数都必须先定义后才能使用。这会导致构造函数代码分布在整个类定义中。研究以下示例代码，然后查看以下代码的描述。

请注意，画布窗口包含单个模型的渲染，该模型是机械臂的基础。这是后续课程中介绍的一系列演示程序的第一次迭代。

点击查看[交互式例子](http://learnwebgl.brown37.net/transformations2/transformations_example1.html#scene-rendering-initialization)

[在新的标签或窗口中打开这个webgl程序](http://learnwebgl.brown37.net/transformations2/simple_transform_example/simple_transform_example.html)

关于执行构造函数代码时发生的预处理操作：

| 行数 | 说明 |
| -- | -- |
| 33-42 | 类函数。 Learn_webgl 对象（learn 参数）已下载所有必需的文件，并将该对象发送给着色器程序、模型和供用户输入的 HTML 输入元素列表。 |
| 45-69, 114-139 | 类构造函数。此代码在创建对象时执行一次。它初始化渲染场景所需的所有数据。 |
| 55 | 创建 Learn_webgl_matrix 对象的一个​​实例。这使您可以访问我们在上一课中讨论的所有矩阵功能。 |
| 56-59 | 我们需要的变换矩阵被创建和初始化。 |
| 118-124 | 检索画布窗口的 GL 上下文。 |
| 130 | 使用顶点着色器和片段着色器创建一个着色器程序。 |
| 131 | 着色器程序成为活动图形管线程序。 |
| 135 | GPU中的缓冲对象被创建，模型数据被复制到GPU。 |
| 138 | 初始化用户事件的回调 |

### 渲染单帧

每次需要对场景进行渲染时，都会调用第73-87行的渲染函数。它采取以下主要行动:

| 行数 | 说明 |
| -- | -- |
| 77 | 保存渲染图像的帧缓冲区被清空为背景色，决定哪些像素是可见的深度缓冲区被清空。 |
| 80 | 导致基础模型旋转的旋转变换被计算出来，因为旋转的角度在每一帧上都在变化。 |
| 84 | 一个单一的顶点变换被计算出来，它包括投影、视图和模型变换。变换的顺序是从右到左。从概念上讲，模型变换首先发生，然后是视图变换，最后是投影变换。 |
| 87 | 使用计算的变换渲染模型。 |

当你 "重启 "一个演示时，Learn_webgl后台进程会使用92-111行的删除函数。正在运行的程序必须从内存中 "清空"，这样才能执行修改后的演示代码。你可以暂时忽略这个删除函数。