## 例1: 每个模型一种颜色

我们将对我们的简单金字塔模型的所有面使用单一的颜色进行渲染。我们需要研究以下问题:

- 着色器程序是如何处理模型顶点的？
- 模型数据是如何组织在对象缓冲区中的？
- 渲染究竟是如何进行的？

### 着色器程序

检查以下演示中的着色器程序，然后研究下面的描述。

点击查看[交互式例子](http://learnwebgl.brown37.net/rendering/render_example_01.html#the-shader-programs)

[在新的标签或窗口中打开这个webgl程序](http://learnwebgl.brown37.net/rendering/simple_pyramid/simple_pyramid.html)

### 顶点着色器（Vertex Shader）

| 行数 | 说明 |
| -- | -- |
| 7-8 | 模型将以所有顶点的相同变换矩阵进行渲染。所有面都将以相同的颜色进行渲染。这些都是统一的值，在渲染开始前会被设置一次。请注意它们的名字以u_开头的惯例。这将有助于你追踪你的变量的类型。(WebGL着色器可以不关心你给变量起什么名字。这个约定是为你--程序员准备的！) |
| 7 | mat4 是一个 4x4 矩阵； 16 个浮点值 |
| 8 | vec4 是 4 个浮点值的向量；在这种情况下，颜色定义为 RGBA（红色、绿色、蓝色、alpha） |
| 10 | 每个渲染的三角形的顶点都会发生变化。因此，变量 a_Vertex 是一个属性变量。它将从缓冲区对象中获取其值。 vec3 是一个包含 3 个浮点值的数组； (x,y,z) |
| 12-15 | main() 函数始终是着色器的入口点。该函数将对模型中的每个顶点执行一次 |
| 14 | 这个着色器在每个顶点上执行一个命令。它使用线性代数矩阵乘法将 4x4 矩阵乘以 4x1 向量。 WebGL 着色器内置了矩阵数学！请注意，顶点只有三个值 (x,y,z)，但矩阵乘法需要 4 个值。顶点转换为 4 分量数组，最后一个分量 w 分量设置为 1.0 |

### 片段着色器（Fragment Shader）

| 行数 | 说明 |
| -- | -- |
| 7 | 像素的颜色将是相同的，所以我们有一个统一的值，u_Color。因为该变量是全局的，并且与全局顶点着色器变量的名称相同，所以该变量被链接到顶点着色器的同名变量 |
| 9-11 | main()函数始终是着色器的入口点。这个函数将为渲染的基元的每个片段（无论是点、线还是三角形）执行一次 |
| 10 | 此着色器对每个片段执行单个命令。它正在设置片段的颜色 |

### 缓冲区对象

渲染这个模型时，唯一改变的属性是它的顶点。因此，我们只需要一个缓冲区对象。记住，缓冲区对象是一个一维的、同质的浮点数值数组。我们需要把定义三角形的所有顶点集中到一个数组中，而且顶点的顺序很重要。在创建数组之前，你需要决定如何对三角形进行渲染。有三种选择：`gl.TRIANGLE`, `gl.TRIANGLE_STRIP`, 或者`g.TRIANGLE_FAN`。此外，当看脸的正面时，每个三角形的顶点必须按逆时针顺序排列。我们的金字塔模型可以使用`gl.TRIANGLE`或`gl.TRIANGLE_STRIP`模式在缓冲区对象中进行一次 "通过 "渲染。让我们保持简单，在这个例子中使用`gl.TRIANGLE`模式。(如果你改变了渲染模式，你将不得不改变顶点的顺序）。

创建缓冲区对象是一个预处理步骤，只需要发生一次。让我们把这个任务分成两部分:
- 以正确的顺序将三角形顶点放入一个一维数组。这是由下图代码中的_buildBufferObjectData()函数完成的。
- 创建顶点并将其上传到GPU的内存中。这是由下图代码中的_createBufferObject()函数完成的。

请注意，这两个函数是JavaScript类定义的私有函数，它们只在构造函数代码被执行时被调用一次。

为填充缓冲区对象而创建的一维数组包含本例中的以下数据。请注意，每个连续的三个值代表一个顶点。

```js
[0.5, -0.25, 0.25, 0, 0.25, 0, -0.5, -0.25, 0.25, -0.5, -0.25, 0.25, 0, 0.25, 0, 0, -0.25, -0.5, 0, -0.25, -0.5, 0, 0.25, 0, 0.5, -0.25, 0.25, 0, -0.25, -0.5, 0.5, -0.25, 0.25, -0.5, -0.25, 0.25]
```

点击查看[交互式例子](http://learnwebgl.brown37.net/rendering/render_example_01.html#the-buffer-object-s)

[在新的标签或窗口中打开这个webgl程序](http://learnwebgl.brown37.net/rendering/simple_pyramid/simple_pyramid2.html)

### 访问着色器变量

为了渲染一个模型，你将在你的着色器程序中设置一些值，然后发出gl.drawArrays()命令。但是你有一个问题。你的数据在你的JavaScript程序的RAM中，而你的着色器程序是在GPU上编译的程序。你怎么能把数据传给着色器呢？这是一个两步的过程:

- 预处理: 获取着色器程序中某个变量的位置。这相当于一个索引，可以用作数组查询。变量在着色器程序中的位置永远不会改变，所以只需要检索一次位置。
- 使用一个变量在着色器程序中的位置来更新它。

要想在着色器程序中获得一个变量的位置，请使用适当的WebGL函数之一:
```js
uint getUniformLocation(Object shader_program, string variable_name);
ulong getAttribLocation(Object shader_program, string variable_name);
```

这些函数的例子可以在上面演示代码的第133-135行找到。

要在着色器程序中设置一个变量的值，请使用适当的WebGL函数之一:
```js
void uniform[1234][fi](uint location, value1, value2, value3, ...);
void uniform[1234][fi]v(uint location, Array values);
void uniformMatrix[234]fv(uint location, bool transpose, Array matrix);
```

括号内的字符，[234]，代表要设置的值的数量。你可以以离散变量的形式发送数值，也可以以单个数组中的多个数值发送。使用数组的函数以v结尾。设置着色器程序变量值的例子可以在上述演示代码的第158、161和176行找到。

### 将一个缓冲区对象与一个属性变量连接起来

一个属性变量从一个数组中提取其值。该数组通常被存储在一个缓冲区对象中。数组中使用的位置由调用gl.drawArrays(mode, start, count)时的第二和第三参数决定。start参数给出了阵列的起始索引，而count参数则指定了要使用多少个顶点。你必须在访问缓冲区对象的值之前启用 "顶点阵列 "的使用。在我们的着色器程序中，将我们的a_Vertex属性变量链接到缓冲区对象上，看起来像这样:
```js
gl.bindBuffer(gl.ARRAY_BUFFER, triangles_vertex_buffer_id);

gl.enableVertexAttribArray(a_Vertex_location);

gl.vertexAttribPointer(a_Vertex_location, 3, gl.FLOAT, false, 0, 0);
```

首先，你必须使一个特定的缓冲区对象处于活动状态。这是用bindBuffer命令完成的。然后用enableVertexAttribArray函数启用从缓冲区对象获取数据。然后你用调用vertexAttribPointer来描述缓冲区对象中数值的组织。第1个参数，a_Vertex_location，是编译后的着色器程序中变量的位置，将从缓冲区的值中设置。让我们把其他参数的正式描述推迟到以后。现在，其他参数告诉着色器，顶点数据每个顶点有3个值，这些值都是浮点。

### 渲染

在示例代码中，gl.drawArrays(mode, start, count)命令被调用了5次。(见第171和180行。)让我们来讨论一下原因。

该着色器被写成以单一颜色进行渲染。我们想渲染一个边缘为黑色的红色金字塔。因此，我们必须至少调用drawArrays()两次：一次是在颜色被设置为红色时，另一次是在颜色被改变为黑色后。检查一下演示代码。注意，颜色在第161行被设置为红色，然后在第171行渲染了三角形。然后在第176行将颜色改为黑色（edge_color），然后使用gl.LINE_LOOP模式将缓冲区对象中的相同顶点用于绘制三角形的边缘。然而，这不能用一条绘制命令来完成，因为顶点在缓冲区对象中不是这样组织的。因此，我们必须在缓冲区中逐步进行，每次都要改变起始索引。

### 总结

在接下来的几课中，我们将修改我们的模型、着色器程序和渲染代码，以产生更复杂的图形。在进行下一课之前，你必须理解上面介绍的概念。因此，在继续学习之前，请再通读一下本课。


