## 着色器入门

### 提纲

这些教程的第12节将详细介绍GL着色器语言（GLSL）。但你需要了解"提纲"和一些基本的语言细节才能开始。

着色器程序在单个顶点和单个片段上工作，一次一个顶点和一个片段。你不能控制对着色器程序的调用。它们是由图形管道自动调用的。

在使用着色器之前，你必须将模型的数据放入GPU顶点对象缓冲区，这只是一个连续的内存块，GPU可以直接访问而不需要使用系统总线。顶点对象缓冲区必须被组织成一个数组，可以使用一个索引来访问数据，以便从数组中获得连续的值。一个模型的数据最好只复制到顶点对象缓冲区一次，作为一个预处理步骤。你将创建许多顶点对象缓冲区。每个顶点对象缓冲区将存储顶点数组的一个特定属性值的数据，或者可能是整个模型的所有顶点属性。

为了渲染一个模型，你的Javascript代码将告诉着色器程序使用哪个顶点对象缓冲区作为其数据源。当你的JavaScript程序调用 **gl.drawArrays(mode, first, count)** 时，图形管道将从数组 **[first]** 顶点开始检索顶点，并从数组中渲染计数顶点。如果你让函数调用 **gl.drawArrays(mode, 5, 10)**，它将渲染数组中 **[5]** 到 **[14]** 的顶点。(数组索引总是以0为下标)

gl.drawArrays函数的模式参数将决定如何使用顶点来渲染元素。可能的绘制模式如图所示：
<center>
<img src='/5/drawing_modes.png' />
</center>

一个顶点着色器将对它从顶点对象缓冲区检索的每个顶点进行相同的计算。顶点着色器的每次执行都是一个独特的运行时实例。你不能在一次执行中设置一个变量，并期望该变量在下一次运行时实例中具有该值。这与你以前的编程语言经验有很大不同。

顶点着色器的工作是给一个叫做gl_Position的特殊变量分配一个4个值的向量，（x,y,z,w）。这个值在图形管道中被传递到管道的下一个阶段。哇，这太奇怪了! 在你看到更具体的例子之前，这可能没有什么意义。但请继续阅读!

顶点着色器的输出gl_Position被传递到图形管道的下一个阶段--"视口转换 "阶段。这将顶点的位置转换为渲染图像中的一个像素位置。这个像素位置（及其相关的渲染数据）被传递到下一个阶段--"光栅化器"。这个阶段决定了一个物体所覆盖的像素。这根据顶点是点、线还是三角形的一部分而有所不同。栅格化器 "将所有需要着色的像素列成一个列表来表示该物体，然后将每个像素及其相关的渲染数据传递给你的碎片着色器。记住，一个像素及其相关的渲染数据被称为一个片段。

片段着色器的工作是将一个RGBA颜色值分配给一个叫做gl_FragColor的特殊变量。这个颜色被传递到图形管道的 "堆积 "阶段，这个颜色值被用来更新正在创建的光栅图像。

让我们来总结一下! 你的顶点着色器将定位一个模型的顶点。然后，你的片段着色器将为由顶点定义的物体所覆盖的所有像素分配颜色。就是这么简单，或者这么复杂，取决于你的观点。请暂停一下，研究一下图形管道的图示。

<center>
<img src='/5/pipeline.png' />
</center>

### 片段(Fragments)

只是为了把事情弄清楚:
- 顶点着色器必须设置一个变量的值：gl_Position。
- 一个片段着色器必须设置一个变量的值：gl_FragColor

但管道中各阶段之间传递的不仅仅是这些值。顶点着色器和片段着色器在顶点基础上共享变量。所以顶点着色器通常会将颜色和其他信息与gl_Position值联系起来。这些信息被传递到图形管道的下一个阶段。在我们开发着色器程序时，我们将努力使数据在管道中的传递方式变得清晰。

### 着色器语言变量

GLSL是一种强类型的语言。所有的变量在使用之前都必须被声明。变量的声明有三个部分。"存储限定符"、"数据类型 "和 "变量名称"。

"存储限定符 "决定了在调用gl.drawArrays()时数值如何变化。

|||
|--|--|
| uniform | 一个数据值，在整个执行gl.drawArrays()的过程中是相同的。 |
| attribute | 一个数据值，在执行gl.drawArrays()的过程中，每个顶点都会变化。 |
| varying | 一个数据值，在执行gl.drawArrays()的每个片段中都会改变。 |

数据类型 "决定了一个变量持有的数据类型。有许多数据类型。现在，我们将把自己限制在以下几个方面：

|||
|--|--|
| int | 一个有符号的整数 |
| float | 一个小数；大约7位数的精度 |
| vec3 | 一个由3个浮点数字组成的向量 |
| vec4 | 一个由4个浮点数字组成的向量 |
| mat4 | 一个4x4的浮点数矩阵。(16个值) |

变量名称以字母或下划线`（_）`开头，只包含字母、数字和下划线字符。变量名是区分大小写的。一个常见的惯例是，统一变量以`u_`开头，属性变量以`a_`开头，而变化变量以`v_`开头。

一个着色器程序的执行总是从`main()`函数开始。你可以根据你的着色器的需要实现尽可能多的子函数。

在`main()`函数之外声明的变量具有全局范围。如果一个同名的变量在顶点着色器和片段着色器中都被声明为全局变量，它就是同一个变量。任何在函数中声明的变量都有局部范围和局部寿命。

注意，JavaScript和GLSL是非常不同的语言，你必须将它们的语法和语义分开。

所有这些问题都会在我们通过实例工作时变得更有意义。如果例子中的着色器有我们还没有讨论过的额外言语，就暂时忽略它吧。这些 "额外的东西 "将在第12节中解释。

### 最简单的着色器

下面可能是最简单的、功能性的着色器程序。顶点和片段着色器程序必须单独存储，因为它们是单独编译的，然后链接到一个着色器程序中。语法与C语言的函数定义、赋值语句、if语句和循环最为接近。与C语言截然不同的是内置的数据类型，将数值转换为不同的数据类型，以及内置的向量和矩阵运算符。

下面是一个非常简单的顶点着色器，它通过一个4x4变换矩阵对每个顶点进行变换。

```js
// Vertex Shader
uniform   mat4 u_Transform;
uniform   vec4 u_Color;

attribute vec3 a_Vertex;

void main() {
  // Transform the location of the vertex
  gl_Position = u_Transform * vec4(a_Vertex, 1.0);
}
```

下面是一个非常简单的片段着色器，它将每个像素设置为相同的颜色。

```js
// Fragment shader
uniform vec4 u_Color;

void main() {
  gl_FragColor = u_Color;
}
```