## 相机介绍

我们想在一个虚拟场景中移动，并从不同的有利位置观察它，就像你使用一个现实世界的相机一样。在现实世界中，一个场景保持静止，而一个人通过移动到各种有利位置来拍照。但事实证明，在虚拟世界中，让相机保持静止并在相机前移动场景，在数学上更有效率。而事实证明，我们可以很容易地将整个场景移到相机前。

我们的虚拟摄像机将位于全局原点，并以-Z轴向下看，Y轴指向上方，X轴指向摄像机的右侧。相机将始终处于这个位置和方向。我们对摄像机的讨论主要集中在如何在静止的摄像机前获得一个理想的场景视图。

<center>
  <img src='/7/camera_orientation.png' />
</center>

### 相机运动与场景运动

一个人利用前景和背景之间的关系来无意识地判断自己是否在移动或周围的物体是否在移动。假设你的眼睛是照相机，你在汽车上行驶。离你很近的物体，如沿路的建筑物，在你的视野中快速移动，远处的风景也在移动，但速度较慢。近处的物体和远处的物体都在移动的事实是你的视觉线索，说明摄像机（也就是你）在移动。如果你停下你的车，看着其他车经过，变化的是背景变得完全静止。前景和背景之间的运动差异使你的头脑能够分辨出你是在移动还是静止。出于这个原因，当我们在摄像机前移动一个场景时，重要的是场景中的一切，包括背景，都要移动。

动画是通过改变场景中物体的位置和方向，或通过改变观看场景的摄像机的位置和方向，或通过移动物体和摄像机来创建的。如果你保持物体静止并移动摄像机，所需的运动与保持摄像机静止并移动物体所需的运动是相反的。例如，考虑一个物体，你想在摄像机前面从左到右移动。如果摄像机处于默认的位置和方向，从-Z轴往下看，物体需要单独从X轴平移，比如从-5到+5。然而，同样的运动可以通过将摄像机从右向左移动产生，例如从+5到-5。如果背景中没有任何东西，就不可能知道是摄像机还是物体在移动，或者两者都在移动。因此，要注意物体的运动和相机的运动对于视觉上相同的运动是相反的。因此，当你在一个场景中移动物体时，你要从物体的坐标系角度考虑。但当你移动摄像机时，你需要从摄像机的坐标系来思考。

### 相机定义

为了定义一个摄像机，我们需要一个位置和一个方向。我们通常把摄像机的位置称为 "眼 "的位置，用一个全局点（eye_x, eye_y, eye_z）来定义其位置。摄像机的方向最好由三个正交轴来定义，这三个正交轴定义了一个局部的、右手的坐标系。为了使这些轴与全局x、y和z坐标轴分开，我们使用u、v和n的名称。（这些名称是任意的，当你在网上搜索时，你会发现摄像机轴的不同符号。） 如果摄像机位于原点，朝下看-Z轴，那么u将与x轴对齐，v将与y轴对齐，而n将与z轴对齐。这可以用下面的符号来概括，其中的符号--->表示 "映射到"。

```js
u --> x
v --> y
n --> z
```

我们可以用下面所示的12个值来指定一个摄像机，它们定义了一个全局点和三个向量。

```js
eye = (eye_x, eye_y, eye_z)  // 相机的位置
u = <ux, uy, uz>             // 指向相机的右侧
v = <vx, vy, vz>             // 从相机指向上方
n = <nx, ny, nz>             // 向后指； -n 是视图的中心
```

这些值必须定义每个摄像机轴，使其与其他两个轴成90度角，并且这些轴形成一个右手坐标系。在数学上，对于一个有效的、右手的相机坐标系来说，以下情况必须是真的。为了简化数学运算，我们总是将轴存储为单位矢量。请记住，交叉积中的向量顺序很重要。如果你调换下面这些向量的顺序，你就不会得到正确的结果。

```js
dot_product(u,v) === 0    // cos(90) == 0
dot_product(v,n) === 0    // cos(90) == 0
dot_product(n,u) === 0    // cos(90) == 0
cross_product(u,v) === n
cross_product(v,n) === u
cross_product(n,u) === v
```

### 指定虚拟相机

程序员很难使用指定右手坐标系的三个归一化向量来定义相机方向。因此，我们通常会用更自然的术语来定义相机，让计算机计算相机坐标系。可以使用两个点和一个向量来实现对相机的简单描述，如下所示：

- 指定相机的位置
  - 这实际上给了我们两个值--眼睛的位置和形成摄像机坐标系轴的参考点。

- 指定相机正在查看的位置。
  - 这个值可以是沿视线在摄像机前面的任何点。它在视线上的确切位置并不重要。这个点定义了-n轴的方向。由于我们将坐标系的轴归一化为单位长度，所以这个向量的方向是我们唯一关心的。
  - 作为程序员，你有责任确保这个点和眼睛的位置形成一个矢量。如果这两个点在同一个位置，-n轴将不是一个有效的矢量，`lookAt()`函数将无法创建一个有效的摄像机坐标系。

- 指定相机“向上”的大致方向
  - 这个向量不一定要精确。典型的值是<0,1,0>，它指向Y轴方向。
  - 此向量与视线向量的负数相交，将产生摄像机坐标系的u轴。
  - 如果 "向上 "矢量正好沿着摄像机的视线，交叉积计算将失败，摄像机的坐标系将无效。作为程序员，你有责任确保视线向量和 "向上向量 "不指向同一方向。
  - 摄像机坐标系的最后一个轴，v，直接指向摄像机的 "上"，是通过取u和n矢量的交叉积来计算的。

基于这些想法，Javascript的`Learn_webgl_matrix`类包含以下功能:

```js
/** -----------------------------------------------------------------
 * 设置相机矩阵.
 * @param M Float32Array 包含相机变换的矩阵.
 * @param eye_x Number 眼点的 x 分量.
 * @param eye_y Number 眼点的 y 分量.
 * @param eye_z Number 眼点的 z 分量.
 * @param center_x Number 正在查看的点的 x 分量.
 * @param center_y Number 正在查看的点的 y 分量.
 * @param center_z Number 正在查看的点的 z 分量.
 * @param up_dx Number 向上方向的向量的 x 分量。
 * @param up_dy Number 向上方向的向量的 y 分量。
 * @param up_dz Number 向上方向的向量的 z 分量。
 */
self.lookAt = function (M, eye_x, eye_y, eye_z, center_x, center_y, center_z, up_dx, up_dy, up_dz) {
```

下面的演示可以让你改变这些参数并立即看到结果。实验一下这些参数，直到你对它们如何改变摄像机视图感到满意。

点击查看[交互式例子](http://learnwebgl.brown37.net/07_cameras/camera_introduction.html#specifying-a-virtual-camera)

[在新的标签或窗口中打开这个webgl程序](http://learnwebgl.brown37.net/07_cameras/camera_lookat/camera_lookat.html)

### 相机错误

一个无效的摄像机定义将产生不可预测的渲染输出。我们已经讨论了会在摄像机中产生错误的条件，但是在代码中加入测试以避免这些潜在的错误是非常重要的。使用lookat()函数计算的摄像机在以下情况下将是无效的。

- "眼睛 "和 "中心 "点是同一个位置。
- "向上的矢量 "与视线（即 "眼睛 "和 "中心 "点之间的矢量）具有相同的方向。对于这种情况，"同一方向 "包括正方向和负方向。从数学上讲，如果 "向上矢量 "和视线矢量之间的角度的正弦值为零，如果矢量之间的角度为0或180，相机定义就会失败。