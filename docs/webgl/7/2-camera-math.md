## 相机数学

正如我们在上一课中所讨论的，在WebGL中，摄像机总是位于原点，从-Z轴向下看。程序员的工作是创建一个变换，使场景在这个静止的摄像机前移动。如果你了解了这一点，你将能够进行更有创造性的摄像工作。本课解释了摄像机转换背后的数学原理。让我们回顾一下摄像机是如何定义的。

### 相机定义

摄像机是由一个位置和一个本地坐标系定义的。我们通常把摄像机的位置称为 "眼睛 "位置。摄像机的局部坐标系由三个正交轴定义，即u、v和n。如果摄像机位于原点，从-Z轴向下看，那么u将与x轴对齐，v将与y轴对齐，而n将与z轴对齐。这被总结为：
```js
u --> x
v --> y
n --> z
```

我们可以用12个值来指定一个摄像机，这些值定义一个全局点和三个向量。

```js
eye = (eye_x, eye_y, eye_z)  // 相机的位置
u = <ux, uy, uz>             // 指向相机的右侧
v = <vx, vy, vz>             // 从相机指向上方
n = <nx, ny, nz>             // 向后指； -n 是视图的中心
```

向量u、v和n定义了相对方向，因为它们所指向的方向是相对于眼睛的位置。

### 将相机移动到其默认位置和方向

给定一个摄像机的定义，如果我们能够开发一个变换，将摄像机移动到全局原点，并将摄像机的轴线与全局轴线对齐，那么我们就可以将这个变换应用到场景中的每个模型。这将把场景移到摄像机的前面

这项任务可以通过两个独立的转换来轻松完成:

- 首先，将摄像机移至原点。
- 其次，旋转摄像机，使摄像机的本地坐标系轴线与全局轴线对齐。

在矩阵格式中，我们有以下内容，其中第一个操作是在链式变换的右边:

```html
┌               ┐   ┌                   ┐   ┌   ┐    ┌    ┐  Eq1
│ rotateToAlign │ * | translateToOrigin | * | x |    | x' |
└               ┘   └                   ┘   | y | =  | y' |
                                            | z |    | z' |
                                            | w |    | w' |
                                            └   ┘    └    ┘
```

`translateToOrigin`变换的创建很简单，因为我们知道眼睛的位置。这个变换是:

```html
                     ┌              ┐  Eq2
translateToOrigin  = │ 1 0 0 -eye_x │
                     | 0 1 0 -eye_y |
                     | 0 0 1 -eye_z |
                     | 0 0 0      1 |
                     └              ┘ 
```

`RotateToAlign`变换同样简单。(我们将在下面开发这个变换。)这个变换是:
```html
                 ┌            ┐  Eq3
rotateToAlign  = │ ux uy uz 0 │
                 | vx vy vz 0 |
                 | nx ny nz 0 |
                 |  0  0  0 1 |
                 └            ┘ 
```

因此，一个能将摄像机移到原点并对齐轴线的变换是:
```html
┌            ┐   ┌              ┐    ┌   ┐    ┌    ┐     Eq4
│ ux uy uz 0 │   │ 1 0 0 -eye_x │    | x |    | x' |
| vx vy vz 0 | * | 0 1 0 -eye_y | *  | y | =  | y' |
| nx ny nz 0 |   | 0 0 1 -eye_z |    | z |    | z' |
|  0  0  0 1 |   | 0 0 0      1 |    | w |    | w' |
└            ┘   └              ┘    └   ┘    └    ┘
```

通过点击乘法符号进行矩阵数学运算! 这是用于所有3D计算机图形的标准相机变换! (实际上，对于所有右手坐标系的三维计算机图形。)

### 推导旋转变换

让我们仔细看看使摄像机的轴线与全局轴线对齐的旋转矩阵。请记住，u轴映射到全局X轴，v轴映射到全局Y轴，而n轴映射到全局Z轴。还要记住，围绕任意轴的一般旋转需要在变换矩阵的左上角3乘3的位置有一个分数值。因此，所需的旋转矩阵必须满足以下三个方程:

```html
┌            ┐   ┌    ┐    ┌   ┐     Eq5 - u --> x，或<ux, uy, uz>映射到<1, 0, 0>。
│ f1 f2 f3 0 │   | ux |    | 1 |
| f4 f5 f6 0 | * | uy | =  | 0 |
| f7 f8 f9 0 |   | uz |    | 0 |
|  0  0  0 1 |   |  0 |    | 0 |
└            ┘   └    ┘    └   ┘
```

```html
┌            ┐   ┌    ┐    ┌   ┐     Eq6 - v --> y，或<vx, vy, vz>映射到<0, 1, 0>。
│ f1 f2 f3 0 │   | vx |    | 0 |
| f4 f5 f6 0 | * | vy | =  | 1 |
| f7 f8 f9 0 |   | vz |    | 0 |
|  0  0  0 1 |   |  0 |    | 0 |
└            ┘   └    ┘    └   ┘
```

```html
┌            ┐   ┌    ┐    ┌   ┐     Eq7 - n --> z，或<nx, ny, nz>映射到<0, 0, 1>。
│ f1 f2 f3 0 │   | nx |    | 0 |
| f4 f5 f6 0 | * | ny | =  | 0 |
| f7 f8 f9 0 |   | nz |    | 1 |
|  0  0  0 1 |   |  0 |    | 0 |
└            ┘   └    ┘    └   ┘
```

我们需要一个能使三个方程都成立的变换。由于矩阵乘法的工作方式，将这三个独立的方程合并成一个方程是可以的，比如这样:

```html
┌            ┐   ┌            ┐    ┌         ┐     Eq8
│ f1 f2 f3 0 │   │ ux vx nx 0 │    | 1 0 0 0 |
| f4 f5 f6 0 | * | uy vy ny 0 | =  | 0 1 0 0 |
| f7 f8 f9 0 |   | uz vz nz 0 |    | 0 0 1 0 |
|  0  0  0 1 |   |  0  0  0 1 |    | 0 0 0 1 |
└            ┘   └            ┘    └         ┘
```

请注意，三个独立方程中的向量成为单个矩阵的列。为了解决旋转矩阵的问题，我们需要将方程两边都乘以已知矩阵的逆值:

![](/7/eq9.png)

然后

![](/7/eq10.png)

这就降低为：

![](/7/eq11.png)

我们需要将摄像机的本地坐标系与全局坐标系对齐的旋转矩阵是：

![](/7/eq12.png)

数学家已经证明，如果一个矩阵的列是相互正交的向量，那么这样一个矩阵的逆就只是它的转置(1)。我们矩阵的列是正交的，因为它们定义了一个有效的右手坐标系，其中每个轴都与其他两个轴成直角。因此，逆矩阵的获得是很简单的--你可以交换行和列：

![](/7/eq13.png)


### 查看执行情况

下面是lookat函数的一个JavaScript实现。它简单地实现了我们刚刚讨论过的数学运算。请注意，变量V、center、eye、up、u、v和n是在创建Learn_webgl_matrix对象时创建过一次的类对象。这些对象在每次调用lookat时都会重复使用。
```js
self.lookAt = function (M, eye_x, eye_y, eye_z, center_x, center_y, center_z, up_dx, up_dy, up_dz) {

  // Local coordinate system for the camera:
  //   u maps to the x-axis
  //   v maps to the y-axis
  //   n maps to the z-axis

  V.set(center, center_x, center_y, center_z);
  V.set(eye, eye_x, eye_y, eye_z);
  V.set(up, up_dx, up_dy, up_dz);

  V.subtract(n, eye, center);  // n = eye - center
  V.normalize(n);

  V.crossProduct(u, up, n);
  V.normalize(u);

  V.crossProduct(v, n, u);
  V.normalize(v);

  var tx = - V.dotProduct(u,eye);
  var ty = - V.dotProduct(v,eye);
  var tz = - V.dotProduct(n,eye);

  // Set the camera matrix
  M[0] = u[0];  M[4] = u[1];  M[8]  = u[2];  M[12] = tx;
  M[1] = v[0];  M[5] = v[1];  M[9]  = v[2];  M[13] = ty;
  M[2] = n[0];  M[6] = n[1];  M[10] = n[2];  M[14] = tz;
  M[3] = 0;     M[7] = 0;     M[11] = 0;     M[15] = 1;
};
```